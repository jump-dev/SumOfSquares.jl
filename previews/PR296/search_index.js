var documenterSearchIndex = {"docs":
[{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"EditURL = \"../../tutorials/Getting started/sos_decomposition.jl\"","category":"page"},{"location":"generated/Getting started/sos_decomposition/#A-trivial-SOS-decomposition-example","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"","category":"section"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"(Image: ) (Image: ) Contributed by: votroto Adapted from: (Blekherman et al., 2012; Examples 3.25)","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"using DynamicPolynomials\nusing SumOfSquares\nimport CSDP","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"The polynomial p = x^2 - x*y^2 + y^4 + 1 is SOS. We can, for example, decompose it as p = 3/4*(x - y^2)^2 + 1/4*(x + y)^2 + 1, which clearly proves that p is SOS, and there are infinitely many other ways to decompose p into sums of squares.","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"We can use SumOfSquares.jl to find such decompositions.","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"First, setup the polynomial of interest.","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"@polyvar x y\np = x^2 - x*y^2 + y^4 + 1","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"Secondly, constrain the polynomial to be nonnegative. SumOfSquares.jl transparently reinterprets polyonmial nonnegativity as the appropriate SOS certificate for polynomials nonnegative on semialgebraic sets.","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"model = SOSModel(CSDP.Optimizer)\n@constraint(model, cref, p >= 0)","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"Thirdly, optimize the feasibility problem!","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"optimize!(model)","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"Lastly, recover a SOS decomposition. In general, SOS decompositions are not unique!","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"sos_dec = sos_decomposition(cref, 1e-4)","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"Converting, rounding, and simplifying - Huzza, Back where we began!","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"polynomial(sos_dec, Float32)","category":"page"},{"location":"generated/Getting started/sos_decomposition/#A-deeper-explanation-and-the-unexplained-1e-4-parameter","page":"A trivial SOS decomposition example","title":"A deeper explanation and the unexplained 1e-4 parameter","text":"","category":"section"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"p = x^2 - x*y^2 + y^4 + 1 can be represented in terms of its Gram matrix as","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"gram = gram_matrix(cref)","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"gram.basis.monomials' * gram.Q * gram.basis.monomials","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"where the matrix gram.Q is positive semidefinite, because p is SOS. If we could only get the decomposition gram.Q = V' * V, the SOS decomposition would simply be ||V * monomials||^2.","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"Unfortunately, we can not use Cholesky decomposition, since gram Q is only semidefinite, not definite. Hence, SumOfSquares.jl uses SVD decomposition instead and discards small singular values (in our case 1e-4).","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"","category":"page"},{"location":"generated/Getting started/sos_decomposition/","page":"A trivial SOS decomposition example","title":"A trivial SOS decomposition example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"EditURL = \"../../tutorials/Polynomial Optimization/bound_on_global_extremum.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/#Bound-on-Global-Extremum","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"","category":"section"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO3 (See Section 4.3 of SOSTOOLS User's Manual)","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"using DynamicPolynomials\n@polyvar x1 x2","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"The Goldstein-Price function f(x) is defined as follows:","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"f1 = x1 + x2 + 1\nf2 = 19 - 14x1 + 3x1^2 - 14x2 + 6x1*x2 + 3x2^2\nf3 = 2x1 - 3x2\nf4 = 18 - 32x1 + 12x1^2 + 48x2 - 36x1*x2 + 27x2^2\nf = (1 + f1^2 * f2) * (30 + f3^2 * f4)","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"using SumOfSquares\nusing CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver);\nnothing #hide","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We create the decision variable gamma that will be the lower bound to the Goldstein-Price function. We maximize it to have the highest possible lower bound.","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"@variable(model, γ)\n@objective(model, Max, γ)","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We constrain gamma to be a lower bound with the following constraint that ensures that f(x_1 x_2) ge gamma for all x_1 x_2.","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"@constraint(model, f >= γ)\n\nJuMP.optimize!(model)","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We verify that the solver has found a feasible solution:","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"JuMP.primal_status(model)","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We can now obtain the lower bound either with value(γ) or objective_value(model):","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"objective_value(model)","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"","category":"page"},{"location":"generated/Polynomial Optimization/bound_on_global_extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"EditURL = \"../../tutorials/Symmetry/permutation_symmetry.jl\"","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/#Symmetry-reduction","page":"Symmetry reduction","title":"Symmetry reduction","text":"","category":"section"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"(Image: ) (Image: ) Adapted from: SymbolicWedderburn example","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"import MutableArithmetics as MA\nusing MultivariatePolynomials\nusing MultivariateBases\n\nusing DynamicPolynomials\n@polyvar x[1:4]","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We would like to find the minimum value of the polynomial","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"poly = sum(x) + sum(x.^2)","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"As we can decouple the problem for each x[i] for which x[i] + x[i]^2 has minimum value 0.25, we would expect to get -1 as answer. Can this decoupling be exploited by SumOfSquares as well ? For this, we need to use a certificate that can exploit the permutation symmetry of the polynomial.","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"using SumOfSquares","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We define the symmetry group as a permutation group in the variables. In order to do that, we define the action of a permutation on a monomial as the monomial obtained after permuting the variables.","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"using PermutationGroups\nG = PermGroup([perm\"(1,2,3,4)\"])","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We can use this certificate as follows:","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"import CSDP\nsolver = CSDP.Optimizer\nmodel = Model(solver)\n@variable(model, t)\n@objective(model, Max, t)\npattern = Symmetry.Pattern(G, Symmetry.VariablePermutation())\ncon_ref = @constraint(model, poly - t in SOSCone(), symmetry = pattern)\noptimize!(model)\nvalue(t)","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We indeed find -1, let's verify that symmetry was exploited:","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"gram_matrix(con_ref).blocks","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"","category":"page"},{"location":"generated/Symmetry/permutation_symmetry/","page":"Symmetry reduction","title":"Symmetry reduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"EditURL = \"../../tutorials/Systems and Control/stabilization_of_nonlinear_systems.jl\"","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/#Stabilization-of-nonlinear-systems","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"","category":"section"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"(Image: ) (Image: ) Adapted from: Examples 1, 2 and 3 of [PPA04]","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"[PPA04] Prajna, Stephen, Pablo A. Parrilo, and Anders Rantzer. Nonlinear control synthesis by convex optimization. IEEE Transactions on Automatic Control 49.2 (2004): 310-314.","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"using DynamicPolynomials\n@polyvar x[1:2]\n\nusing SumOfSquares\nusing CSDP\nusing LinearAlgebra # for ⋅\nusing MultivariatePolynomials\ndivergence(f) = sum(differentiate.(f, x))\nfunction controller(f, g, b, α, degs)\n    solver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\n    model = SOSModel(solver)\n    a = 1\n    monos = monomials(x, degs)\n    N = length(monos) + 1\n    @variable(model, c[1:N] in MOI.NormOneCone(N))\n    c_poly = polynomial(c[2:end], monos)\n    fagc = f * a + g * c_poly\n    @constraint(model, b * divergence(fagc) - α * differentiate(b, x) ⋅ fagc in SOSCone())\n    @objective(model, Min, c[1])\n    optimize!(model)\n    if termination_status(model) != MOI.OPTIMAL\n        @warn(\"Termination status $(termination_status(model)): $(raw_status(model))\")\n    end\n    u = value(c_poly) / value(a)\n    return MultivariatePolynomials.map_coefficients(coef -> abs(coef) < 1e-6 ? 0.0 : coef, u)\nend\n\nimport DifferentialEquations, Plots\nfunction phase_plot(f, quiver_scaling, Δt, X0, solver = DifferentialEquations.Tsit5())\n    ∇(vx, vy) = [fi(x[1] => vx, x[2] => vy) for fi in f]\n    ∇pt(v, p, t) = ∇(v[1], v[2])\n    function traj(v0)\n        tspan = (0.0, Δt)\n        prob = DifferentialEquations.ODEProblem(∇pt, v0, tspan)\n        return DifferentialEquations.solve(prob, solver, reltol=1e-8, abstol=1e-8)\n    end\n    ticks = -5:0.5:5\n    X = repeat(ticks, 1, length(ticks))\n    Y = X'\n    Plots.quiver(X, Y, quiver = (x, y) -> ∇(x, y) / quiver_scaling, linewidth=0.5)\n    for x0 in X0\n        Plots.plot!(traj(x0), vars=(1, 2), label = nothing)\n    end\n    Plots.plot!(xlims = (-5, 5), ylims = (-5, 5))\nend","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/#Example-1","page":"Stabilization of nonlinear systems","title":"Example 1","text":"","category":"section"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"g = [0, 1]\nf = [x[2] - x[1]^3 + x[1]^2, 0]\nb = 3x[1]^2 + 2x[1]*x[2] + 2x[2]^2\nu = controller(f, g, b, 4, 0:3)","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"We find the controller above which gives the following phase plot.","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"phase_plot(f + g * u, 200, 10.0, [[x1, x2] for x1 in -5:5:5, x2 in -5:5:5 if x1 != 0 || x2 != 0])","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/#Example-2","page":"Stabilization of nonlinear systems","title":"Example 2","text":"","category":"section"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"g = [0, 1]\nf = [2x[1]^3 + x[1]^2*x[2] - 6x[1]*x[2]^2 + 5x[2]^3, 0]\nb = x[1]^2 + x[2]^2\nu = controller(f, g, b, 2.5, 0:3)","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"We find the controller above which gives the following phase plot.","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"phase_plot(f + g * u, 2000, 5.0, [[-1.0, -5.0], [1.0, 5.0]])","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/#Example-3","page":"Stabilization of nonlinear systems","title":"Example 3","text":"","category":"section"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"g = [0, x[2]]\nf = [-6x[1]*x[2]^2 - x[1]^2*x[2] + 2x[2]^3, 0]\nb = x[1]^2 + x[2]^2\nu = controller(f, g, b, 3, 0:2)","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"We find the controller above which gives the following phase plot.","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"X0 = [Float64[x1, x2] for x1 in -5:5:5, x2 in -5:5:5 if x2 != 0]\nε = 1e-4 # We separate the starting point slightly from the hyperplane `x2 = 0` which is invariant.\npush!(X0, [-4,  ε])\npush!(X0, [-3, -ε])\npush!(X0, [ 3,  ε])\npush!(X0, [ 4, -ε])\nphase_plot(f + g * u, 2000, 10.0, X0)","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"","category":"page"},{"location":"generated/Systems and Control/stabilization_of_nonlinear_systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"reference/constraints/#Attributes","page":"Constraints","title":"Attributes","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.PolyJuMP.MomentsAttribute\nSumOfSquares.MultivariateMoments.moments(::SumOfSquares.JuMP.ConstraintRef)\nGramMatrix\nSumOfSquares.GramMatrixAttribute\ngram_matrix\ngram_operate\nSumOfSquares.MomentMatrixAttribute\nmoment_matrix\nSumOfSquares.CertificateBasis\ncertificate_basis\ncertificate_monomials\nSumOfSquares.LagrangianMultipliers\nlagrangian_multipliers\nSOSDecomposition\nSOSDecompositionWithDomain\nSumOfSquares.SOSDecompositionAttribute\nsos_decomposition","category":"page"},{"location":"reference/constraints/#PolyJuMP.MomentsAttribute","page":"Constraints","title":"PolyJuMP.MomentsAttribute","text":"MomentsAttribute(N)\nMomentsAttribute()\n\nA constraint attribute for the vector of moments corresponding to the constraint that a polynomial is zero in the full space in result N. If the polynomial is constrained to be zero in an algebraic set, it is the moments for the constraint once it is rewritten into an constraint on the full space. If N is omitted, it is 1 by default.\n\nExamples\n\nConsider the following program:\n\n@variable(model, α)\n@variable(model, β ≤ 1)\n\nusing DynamicPolynomials\n@polyvar x y\ncref = @constraint(model, α * x - β * y == 0, domain = @set x == y)\n\nThe constraint is equivalent to\n\n@constraint(model, (α - β) * y == 0)\n\nfor which the dual is the 1-element vector with the moment of y of value -1. This is the result of moments(cref). However, the dual of cref obtained by dual(cref) is the 2-elements vector with both the moments of x and y of value -1.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#MultivariateMoments.moments-Tuple{ConstraintRef}","page":"Constraints","title":"MultivariateMoments.moments","text":"moments(cref::JuMP.ConstraintRef)\n\nReturn the MomentsAttribute of cref.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#SumOfSquares.GramMatrix","page":"Constraints","title":"SumOfSquares.GramMatrix","text":"struct GramMatrix{T, B, U, MT <: AbstractMatrix{T}} <: AbstractGramMatrix{T, B, U}\n    Q::MT\n    basis::B\nend\n\nGram matrix x^top Q x where Q is a symmetric matrix indexed by the vector of polynomials of the basis basis.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.GramMatrixAttribute","page":"Constraints","title":"SumOfSquares.GramMatrixAttribute","text":"GramMatrixAttribute(result_index)\nGramMatrixAttribute()\n\nA constraint attribute for the GramMatrix of a constraint, that is, the positive semidefinite matrix Q indexed by the monomials in the vector X such that X^top Q X is the sum-of-squares certificate of the constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.gram_matrix","page":"Constraints","title":"SumOfSquares.gram_matrix","text":"gram_matrix(cref::JuMP.ConstraintRef)\n\nReturn the GramMatrixAttribute of cref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#SumOfSquares.gram_operate","page":"Constraints","title":"SumOfSquares.gram_operate","text":"gram_operate(::typeof(+), p::GramMatrix, q::GramMatrix)\n\nComputes the Gram matrix equal to the sum between p and q. On the opposite, p + q gives a polynomial equal to p + q. The polynomial p + q can also be obtained by polynomial(gram_operate(+, p, q)).\n\n\n\n\n\ngram_operate(/, p::GramMatrix, α)\n\nComputes the Gram matrix equal to p / α. On the opposite, p / α gives a polynomial equal to p / α. The polynomial p / α can also be obtained by polynomial(gram_operate(/, p, α)).\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#SumOfSquares.MomentMatrixAttribute","page":"Constraints","title":"SumOfSquares.MomentMatrixAttribute","text":"MomentMatrixAttribute(N)\nMomentMatrixAttribute()\n\nA constraint attribute fot the MomentMatrix of a constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#MultivariateMoments.moment_matrix","page":"Constraints","title":"MultivariateMoments.moment_matrix","text":"moment_matrix(cref::JuMP.ConstraintRef)\n\nReturn the MomentMatrixAttribute of cref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#SumOfSquares.CertificateBasis","page":"Constraints","title":"SumOfSquares.CertificateBasis","text":"struct CertificateBasis <: MOI.AbstractConstraintAttribute end\n\nA constraint attribute for the basis indexing the GramMatrixAttribute and MomentMatrixAttribute certificates.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.certificate_basis","page":"Constraints","title":"SumOfSquares.certificate_basis","text":"certificate_basis(cref::JuMP.ConstraintRef)\n\nReturn the CertificateBasis of cref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#SumOfSquares.certificate_monomials","page":"Constraints","title":"SumOfSquares.certificate_monomials","text":"certificate_monomials(cref::JuMP.ConstraintRef)\n\nReturn the monomials of certificate_basis. If the basis if not MultivariateBases.AbstractMonomialBasis, an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#SumOfSquares.LagrangianMultipliers","page":"Constraints","title":"SumOfSquares.LagrangianMultipliers","text":"LagrangianMultipliers(N)\nLagrangianMultipliers()\n\nA constraint attribute fot the LagrangianMultipliers associated to the inequalities of the domain of a constraint. There is one multiplier per inequality and no multiplier for equalities as the equalities are handled by reducing the polynomials over the ideal they generate instead of explicitely creating multipliers.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.lagrangian_multipliers","page":"Constraints","title":"SumOfSquares.lagrangian_multipliers","text":"lagrangian_multipliers(cref::JuMP.ConstraintRef)\n\nReturn the LagrangianMultipliers of cref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#SumOfSquares.SOSDecomposition","page":"Constraints","title":"SumOfSquares.SOSDecomposition","text":"struct SOSDecomposition{T, PT}\n\nRepresents a Sum-of-Squares decomposition without domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.SOSDecompositionWithDomain","page":"Constraints","title":"SumOfSquares.SOSDecompositionWithDomain","text":"struct SOSDecompositionWithDomain{T, PT, S}\n\nRepresents a Sum-of-Squares decomposition on a basic semi-algebraic domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.SOSDecompositionAttribute","page":"Constraints","title":"SumOfSquares.SOSDecompositionAttribute","text":"struct SOSDecompositionAttribute\n    ranktol::Real\n    dec::MultivariateMoments.LowRankLDLTAlgorithm\n    result_index::Int\nend\n\nA constraint attribute for the SOSDecomposition of a constraint. By default, it is computed using SOSDecomposition(gram, ranktol, dec) where gram is the value of the GramMatrixAttribute.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#SumOfSquares.sos_decomposition","page":"Constraints","title":"SumOfSquares.sos_decomposition","text":"sos_decomposition(cref::JuMP.ConstraintRef)\n\nReturn the SOSDecompositionAttribute of cref.\n\n\n\n\n\nsos_decomposition(cref::JuMP.ConstraintRef, K<:AbstractBasicSemialgebraicSet)\n\nReturn representation in the quadraic module associated with K.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"SAGE decomposition attribute:","category":"page"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.PolyJuMP.SAGE.Decomposition\nSumOfSquares.PolyJuMP.SAGE.DecompositionAttribute","category":"page"},{"location":"reference/constraints/#PolyJuMP.SAGE.Decomposition","page":"Constraints","title":"PolyJuMP.SAGE.Decomposition","text":"struct Decomposition{T, PT}\n\nRepresents a SAGE decomposition.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#PolyJuMP.SAGE.DecompositionAttribute","page":"Constraints","title":"PolyJuMP.SAGE.DecompositionAttribute","text":"struct DecompositionAttribute{T} <: MOI.AbstractConstraintAttribute\n    tol::T\nend\n\nA constraint attribute for the Decomposition of a constraint.\n\n\n\n\n\n","category":"type"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"EditURL = \"../../tutorials/Symmetry/cyclic.jl\"","category":"page"},{"location":"generated/Symmetry/cyclic/#Cyclic-symmetry-for-Sums-of-Hermitian-Squares","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"","category":"section"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"We start by defining the Cyclic group.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"using GroupsCore\nimport PermutationGroups\n\nstruct CyclicElem <: GroupElement\n    n::Int\n    id::Int\nend\nBase.:(==)(a::CyclicElem, b::CyclicElem) = a.n == b.n && a.id == b.id\nBase.inv(el::CyclicElem) = CyclicElem(el.n, (el.n - el.id) % el.n)\n\nfunction Base.:*(a::CyclicElem, b::CyclicElem)\n    return CyclicElem(a.n, (a.id + b.id) % a.n)\nend\nBase.:^(el::CyclicElem, k::Integer) = CyclicElem(el.n, (el.id * k) % el.n)\n\nBase.conj(a::CyclicElem, b::CyclicElem) = inv(b) * a * b\nBase.:^(a::CyclicElem, b::CyclicElem) = conj(a, b)\n\nfunction PermutationGroups.order(el::CyclicElem)\n    return div(el.n, gcd(el.n, el.id))\nend\n\nstruct CyclicGroup <: Group\n    n::Int\nend\nBase.eltype(::CyclicGroup) = CyclicElem\nBase.one(c::Union{CyclicGroup, CyclicElem}) = CyclicElem(c.n, 0)\nPermutationGroups.gens(c::CyclicGroup) = [CyclicElem(c.n, 1)]\nPermutationGroups.order(::Type{T}, c::CyclicGroup) where {T} = convert(T, c.n)\nfunction Base.iterate(c::CyclicGroup, prev::CyclicElem=CyclicElem(c.n, -1))\n    id = prev.id + 1\n    if id >= c.n\n        return nothing\n    else\n        next = CyclicElem(c.n, id)\n        return next, next\n    end\nend","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"Now we define that the cyclic group acts on monomial by permuting variables cyclically. So for instance, CyclicElem(3, 1) would transform x_1^3*x_2*x_3^4 into x_1^4*x_2^3*x_3.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"import MultivariatePolynomials as MP\n\nusing SumOfSquares\n\nstruct Action{V<:MP.AbstractVariable} <: Symmetry.OnMonomials\n    variables::Vector{V}\nend\nSymmetry.SymbolicWedderburn.coeff_type(::Action) = Float64\nfunction Symmetry.SymbolicWedderburn.action(a::Action, el::CyclicElem, mono::MP.AbstractMonomial)\n    return prod(MP.powers(mono), init=MP.constant_monomial(mono)) do (var, exp)\n        index = findfirst(isequal(var), a.variables)\n        new_index = mod1(index + el.id, el.n)\n        return a.variables[new_index]^exp\n    end\nend\n\nusing DynamicPolynomials\n@polyvar x[1:3]\naction = Action(x)\ng = CyclicElem(3, 1)\nSymmetry.SymbolicWedderburn.action(action, g, x[1]^3 * x[2] * x[3]^4)","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"The following polynomial poly is invariant under the action of the group G.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"N = 3\nG = CyclicGroup(N)\npoly = sum(x[i] * x[mod1(i + 1, N)] for i in 1:N) + sum(x.^2)\nSymmetry.SymbolicWedderburn.action(action, g, poly)","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"Let's now find the minimum of p by exploiting this symmetry.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"import CSDP\nsolver = CSDP.Optimizer\nmodel = Model(solver)\n@variable(model, t)\n@objective(model, Max, t)\npattern = Symmetry.Pattern(G, action)\ncon_ref = @constraint(model, poly - t in SOSCone(), symmetry = pattern)\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"Let's look at the symmetry adapted basis used.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"for gram in gram_matrix(con_ref).blocks\n    println(gram.basis.polynomials)\n    display(gram.Q)\nend","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"Let's look into more details at the last two elements of the basis.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"basis = [(x[1] + x[2] - 2x[3])/√6, (x[1] - x[2])/√2]","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"This actually constitutes the basis for an invariant subspace corresponding to a group character of degree 2 and multiplicity 1. This means that it decomposes the semidefinite matrix into 2 blocks of size 1-by-1 that are equal. Indeed, we see above that gram.Q is identically equal for both. As the group is generated by one element g, we can just verify it by verifying its invariance under g. The image of each element under the basis is:","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"image = [Symmetry.SymbolicWedderburn.action(action, g, p) for p in basis]","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"We can see that they are both still in the same 2-dimensional subspace.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"a = -1/2\nb = √3/2\n[a -b; b a] * basis","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"In fact, these last two basis comes from the real decomposition of a complex one.","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"import CSDP\nsolver = CSDP.Optimizer\nmodel = Model(solver)\n@variable(model, t)\n@objective(model, Max, t)\npattern = Symmetry.Pattern(G, action)\ncone = SumOfSquares.NonnegPolyInnerCone{MOI.HermitianPositiveSemidefiniteConeTriangle}()\ncon_ref = @constraint(model, poly - t in cone, symmetry = pattern)\noptimize!(model)\nsolution_summary(model)\n\nfor gram in gram_matrix(con_ref).blocks\n    println(gram.basis.polynomials)\n    display(gram.Q)\nend","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"We can see that the real invariant subspace was in fact coming from two complex conjugate complex invariant subspaces:","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"complex_basis = basis[1] + im * basis[2]\nimage = Symmetry.SymbolicWedderburn.action(action, g, complex_basis)","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"And there is a direct correspondance between the representation of the real and complex versions:","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"(a + b * im) * complex_basis","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"","category":"page"},{"location":"generated/Symmetry/cyclic/","page":"Cyclic symmetry for Sums of Hermitian Squares","title":"Cyclic symmetry for Sums of Hermitian Squares","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/internal/#Internal-functions","page":"Internal functions","title":"Internal functions","text":"","category":"section"},{"location":"reference/internal/","page":"Internal functions","title":"Internal functions","text":"SumOfSquares.Certificate.Symmetry.orthogonal_transformation_to\nSumOfSquares.Certificate.Symmetry._reorder!\nSumOfSquares.Certificate.Symmetry._rotate_complex\nPolyJuMP.QCQP._subs_ensure_moi_order","category":"page"},{"location":"reference/internal/#SumOfSquares.Certificate.Symmetry.orthogonal_transformation_to","page":"Internal functions","title":"SumOfSquares.Certificate.Symmetry.orthogonal_transformation_to","text":"orthogonal_transformation_to(A, B)\n\nReturn an orthogonal transformation U such that A = U' * B * U\n\nGiven Schur decompositions A = Z_A * S_A * Z_A' B = Z_B * S_B * Z_B' Since P' * S_A * P = D' * S_B * D, we have A = Z_A * P * Z_B' * B * Z_B * P' * Z_A'\n\n\n\n\n\n","category":"function"},{"location":"reference/internal/#SumOfSquares.Certificate.Symmetry._reorder!","page":"Internal functions","title":"SumOfSquares.Certificate.Symmetry._reorder!","text":"_reorder!(F::LinearAlgebra.Schur{T}) where {T}\n\nGiven a Schur decomposition of a, reorder it so that its eigenvalues are in in increasing order.\n\nNote that if T<:Real, F.Schur is quasi upper triangular. By (quasi), we mean that there may be nonzero entries in S[i+1,i] representing complex conjugates. In that case, the complex conjugate are permuted together. If T<:Complex, then S is triangular.\n\n\n\n\n\n","category":"function"},{"location":"reference/internal/#SumOfSquares.Certificate.Symmetry._rotate_complex","page":"Internal functions","title":"SumOfSquares.Certificate.Symmetry._rotate_complex","text":"_rotate_complex(A::AbstractMatrix{T}, B::AbstractMatrix{T}; tol = Base.rtoldefault(real(T))) where {T}\n\nGiven (quasi) upper triangular matrix A and B that have the eigenvalues in the same order except the complex pairs which may need to be (signed) permuted, returns an othogonal matrix P such that P' * A * P and B have matching low triangular part. The upper triangular part will be dealt with by _sign_diag.\n\nBy (quasi), we mean that if S is a Matrix{<:Real}, then there may be nonzero entries in S[i+1,i] representing complex conjugates. If S is a Matrix{<:Complex}, then S is upper triangular so there is nothing to do.\n\n\n\n\n\n","category":"function"},{"location":"reference/internal/#PolyJuMP.QCQP._subs_ensure_moi_order","page":"Internal functions","title":"PolyJuMP.QCQP._subs_ensure_moi_order","text":"_subs_ensure_moi_order(p::PolyJuMP.ScalarPolynomialFunction, old, new)\n\nSubstitutes old MP.variables(p.polynomial) with new vars, while re-sorting the MOI p.variables to get them in the correct order after substitution.\n\n\n\n\n\n","category":"function"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"EditURL = \"../../tutorials/Symmetry/even_reduction.jl\"","category":"page"},{"location":"generated/Symmetry/even_reduction/#Even-reduction","page":"Even reduction","title":"Even reduction","text":"","category":"section"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"using DynamicPolynomials\n@polyvar x","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"We would like to find the minimum value of the following polynomial:","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"poly = x^4 - 2x^2\n\nusing SumOfSquares","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"We define the custom action as follows:","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"struct OnSign <: Symmetry.OnMonomials end\nusing PermutationGroups\nimport SymbolicWedderburn\nSymbolicWedderburn.coeff_type(::OnSign) = Float64\nfunction SymbolicWedderburn.action(::OnSign, p::Permutation, mono::AbstractMonomial)\n    if isone(p) || iseven(DynamicPolynomials.degree(mono))\n        return 1 * mono\n    else\n        @assert p.perm == perm\"(1,2)\"\n        return -1 * mono\n    end\nend\nG = PermGroup([perm\"(1,2)\"])","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"We can exploit the symmetry as follows:","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"import CSDP\nsolver = CSDP.Optimizer\nmodel = Model(solver)\n@variable(model, t)\n@objective(model, Max, t)\npattern = Symmetry.Pattern(G, OnSign())\ncon_ref = @constraint(model, poly - t in SOSCone(), symmetry = pattern)\noptimize!(model)\nvalue(t)","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"We indeed find -1, let's verify that symmetry was exploited:","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"gram_matrix(con_ref)","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"","category":"page"},{"location":"generated/Symmetry/even_reduction/","page":"Even reduction","title":"Even reduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"EditURL = \"../../tutorials/Systems and Control/julia_set.jl\"","category":"page"},{"location":"generated/Systems and Control/julia_set/#Outer-approximation-of-Julia-set","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"","category":"section"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"(Image: ) (Image: ) Adapted from: Section 7.1.3 of [KHJ14]","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"[KHJ14] Milan Korda, Didier Henrion, and Colin N. Jones. Convex computation of the maximum controlled invariant set for polynomial control systems. SIAM Journal on Control and Optimization 52.5 (2014): 2944-2969.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"The Julia map is defined as follows:","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"function julia_map(point, c)\n    a, b = point\n    return [a^2 - b^2 + real(c), 2a * b + imag(c)]\nend","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"The *escape radius\" is the radius r such that r^2 ≥ r + abs(c). Ouside of the circle of that radius, all points diverge so we know the Julia set belongs to that circle.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"escape_radius(c) = (1 + √(1 + 4 * abs(c))) / 2","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"To check whether a point is in the Julia set, we can iterate and once the point leaves the circle of escape radius, we consider that it is not in the Julia set, if it stays in the set, we consider that it is in the Julia set. This gives an outer approximation that converges to the Julia set when m increases.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"using LinearAlgebra\nfunction in_set(x, c, m=2000)\n    r = escape_radius(c)\n    for i in 1:m\n        if norm(x) > r\n            return false\n        end\n        x = julia_map(x, c)\n    end\n    return true\nend","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"To sort of minimize a level set of a polynomial we minimize integral of that polynomial. We borrow the following from https://doi.org/10.1080/00029890.2001.11919774","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"using SpecialFunctions\nusing DynamicPolynomials\nβ(α) = (α + 1) / 2\nfunction circle_integral(mono::AbstractMonomial)\n    if any(isodd, exponents(mono))\n        return 0.0\n    else\n        return 2 * prod(gamma ∘ β, exponents(mono)) / gamma(sum(β, exponents(mono)))\n    end\nend\nfunction disk_integral(mono::AbstractMonomial, r)\n    d = degree(mono) + nvariables(mono)\n    return circle_integral(mono) * r^d / d\nend\nfunction disk_integral(p::AbstractPolynomialLike, r)\n    return sum(MultivariatePolynomials.coefficient(t) * disk_integral(monomial(t), r) for t in terms(p))\nend","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"The following function implements [KHJ14, (8)].","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"using SumOfSquares\nfunction outer_approximation(solver, d::Int, c; α = 1/2)\n    @polyvar x[1:2]\n    model = SOSModel(solver)\n    r = escape_radius(c)\n    S = @set sum(x.^2) <= r^2\n    @variable(model, v, Poly(monomials(x, 0:2d)))\n    @variable(model, w0, SOSPoly(monomials(x, 0:d)))\n    @variable(model, w1, SOSPoly(monomials(x, 0:(d - 1))))\n    @constraint(model, α * v(x => julia_map(x, c)) <= v, domain = S)\n    w = w0 + w1 * (r^2 - sum(x.^2))\n    @constraint(model, w >= v + 1, domain = S)\n    @objective(model, Min, disk_integral(w, r))\n    optimize!(model)\n    if primal_status(model) == MOI.NO_SOLUTION\n        return\n    end\n    return model\nend","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"The following function plots the Julia set with the outer approximation.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"using ImplicitPlots\nusing Plots\nfunction julia_plot(poly, c, n=200, m=1000; tol=1e-6, res = 1000)\n    r = escape_radius(c)\n    p = implicit_plot(poly; xlims=(-r, r) .* 1.1, ylims=(-r, r), resolution = res, label=\"\")\n    θ = range(0, stop=2π, length=100)\n    points = Vector{Float64}[]\n    as = range(-r, r, length=n)\n    bs = range(-r, r, length=n)\n    for a in as, b in bs\n        point = [a, b]\n        if in_set(point, c, m)\n            push!(points, point)\n        end\n    end\n    xs = [point[1] for point in points]\n    ys = [point[2] for point in points]\n    scatter!(p, xs, ys, label=\"\", markerstrokewidth=0, markersize=1.5, m=:pixel)\n    return p\nend","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"We need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"import CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"Let's start with the value of c corresponding to the left image of [KHJ14, Figure 3] and with degree 2.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"c = -0.7 + 0.2im\nmodel = outer_approximation(solver, 2, c)\nsolution_summary(model)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"We visualize below:","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"julia_plot(value(model[:v]), c)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"Let's now look at degree 4.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"model = outer_approximation(solver, 4, c)\nsolution_summary(model)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"We visualize below:","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"julia_plot(value(model[:v]), c)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"Let's now use the value of c corresponding to the right image of [KHJ14, Figure 3] and with degree 2.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"c = -0.9 + 0.2im\nmodel = outer_approximation(solver, 2, c)\nsolution_summary(model)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"We visualize below:","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"julia_plot(value(model[:v]), c)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"Let's now look at degree 4.","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"model = outer_approximation(solver, 4, c)\nsolution_summary(model)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"We visualize below:","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"julia_plot(value(model[:v]), c)","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"","category":"page"},{"location":"generated/Systems and Control/julia_set/","page":"Outer approximation of Julia set","title":"Outer approximation of Julia set","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"EditURL = \"../../tutorials/Noncommutative and Hermitian/noncommutative_variables.jl\"","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/#Noncommutative-variables","page":"Noncommutative variables","title":"Noncommutative variables","text":"","category":"section"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"(Image: ) (Image: ) Adapted from: Examples 2.11 and 2.2 of [BKP16]","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"[BKP16] Sabine Burgdorf, Igor Klep, and Janez Povh. Optimization of polynomials in non-commuting variables. Berlin: Springer, 2016.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/#Example-2.11","page":"Noncommutative variables","title":"Example 2.11","text":"","category":"section"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We consider the Example 2.11 of [BKP16] in which the polynomial with noncommutative variables (x * y + x^2)^2 = x^4 + x^3y + xyx^2 + xyxy is tested to be sum-of-squares.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"using DynamicPolynomials\n@ncpolyvar x y\np = (x * y + x^2)^2","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"using SumOfSquares\nimport CSDP\noptimizer_constructor = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = Model(optimizer_constructor)\ncon_ref = @constraint(model, p in SOSCone())\n\noptimize!(model)","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We see that both the monomials xy and yx are considered separately, this is a difference with the commutative version.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"certificate_basis(con_ref)","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We see that the solution correctly uses the monomial xy instead of yx. We also identify that only the monomials x^2 and xy would be needed. This would be dectected by the Newton chip method of [Section 2.3, BKP16].","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"gram_matrix(con_ref).Q","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"When asking for the SOS decomposition, the numerically small entries makes the solution less readable.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"sos_decomposition(con_ref)","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"They are however easily discarded by using a nonzero tolerance:","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"sos_decomposition(con_ref, 1e-6)","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/#Example-2.2","page":"Noncommutative variables","title":"Example 2.2","text":"","category":"section"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We consider now the Example 2.2 of [BKP16] in which the polynomial with noncommutative variables (x + x^10y^20x^10)^2 is tested to be sum-of-squares.","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"using DynamicPolynomials\n@ncpolyvar x y\nn = 10\np = (x + x^n * y^(2n) * x^n)^2\n\nusing SumOfSquares\nmodel = Model(optimizer_constructor)\ncon_ref = @constraint(model, p in SOSCone())\n\noptimize!(model)","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"Only two monomials were considered for the basis of the gram matrix thanks to the Augmented Newton chip method detailed in [Section 2.4, BKP16].","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"certificate_basis(con_ref)\n\ngram_matrix(con_ref).Q\n\nsos_decomposition(con_ref, 1e-6)","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"","category":"page"},{"location":"generated/Noncommutative and Hermitian/noncommutative_variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"EditURL = \"../../tutorials/Polynomial Optimization/ellipsoid.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/#Exterior-of-ellipsoid","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"","category":"section"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"(Image: ) (Image: ) Adapted from: (Floudas et al., 1999; Section 3.5) and (Lasserre, 2009; Table 5.1)","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/#Introduction","page":"Exterior of ellipsoid","title":"Introduction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"Consider the polynomial optimization problem from (Floudas et al., 1999; Section 3.5)","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"A = [\n     0  0  1\n     0 -1  0\n    -2  1 -1\n]\nbz = [3, 0, -4] - [0, -1, -6]\ny = [1.5, -0.5, -5]\n\nusing DynamicPolynomials\n@polyvar x[1:3]\np = -2x[1] + x[2] - x[3]\nusing SumOfSquares\ne = A * x - y\nf = e'e - bz'bz / 4\nK = @set sum(x) <= 4 && 3x[2] + x[3] <= 6 && f >= 0 && 0 <= x[1] && x[1] <= 2 && 0 <= x[2] && 0 <= x[3] && x[3] <= 3","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"import Clarabel\nsolver = Clarabel.Optimizer","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following function searches for the largest lower bound and finds zero using the dth level of the hierarchy`.","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"function solve(d)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = K, maxdegree = d)\n    optimize!(model)\n    println(solution_summary(model))\n    return model\nend","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"The first level of the hierarchy gives a lower bound of -7`","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"model2 = solve(2)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"The second level improves the lower bound","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"model4 = solve(4)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"The third level improves it even further","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"model6 = solve(6)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"The fourth level finds the optimal objective value as lower bound.","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"model8 = solve(8)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"","category":"page"},{"location":"generated/Polynomial Optimization/ellipsoid/","page":"Exterior of ellipsoid","title":"Exterior of ellipsoid","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"EditURL = \"../../tutorials/Polynomial Optimization/bilinear.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/#Bilinear-terms","page":"Bilinear terms","title":"Bilinear terms","text":"","category":"section"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"(Image: ) (Image: ) Adapted from: (Floudas et al., 1999; Section 3.1) and (Lasserre, 2009; Table 5.1)","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/#Introduction","page":"Bilinear terms","title":"Introduction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"Consider the polynomial optimization problem from (Floudas et al., 1999; Section 3.1).","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"using DynamicPolynomials\n@polyvar x[1:8]\np = sum(x[1:3])\nusing SumOfSquares\nK = @set 0.0025 * (x[4] + x[6]) <= 1 &&\n    0.0025 * (-x[4] + x[5] + x[7]) <= 1 &&\n    0.01 * (-x[5] + x[8]) <= 1 &&\n    100x[1] - x[1] * x[6] + 8333.33252x[4] <= 250000/3 &&\n    x[2] * x[4] - x[2] * x[7] - 1250x[4] + 1250x[5] <= 0 &&\n    x[3] * x[5] - x[3] * x[8] - 2500x[5] + 1250000 <= 0 &&\n    100 <= x[1] && x[1] <= 10000 &&\n    1000 <= x[2] && x[2] <= 10000 &&\n    1000 <= x[3] && x[3] <= 10000 &&\n    10 <= x[4] && x[4] <= 1000 &&\n    10 <= x[5] && x[5] <= 1000 &&\n    10 <= x[6] && x[6] <= 1000 &&\n    10 <= x[7] && x[7] <= 1000 &&\n    10 <= x[8] && x[8] <= 1000","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"import Clarabel\nsolver = Clarabel.Optimizer","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following function searches for the largest lower bound and finds zero using the dth level of the hierarchy`.","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"function solve(d)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = K, maxdegree = d)\n    optimize!(model)\n    println(solution_summary(model))\n    return model\nend","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"The first level of the hierarchy gives a lower bound of 2100","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"model2 = solve(2)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"","category":"page"},{"location":"generated/Polynomial Optimization/bilinear/","page":"Bilinear terms","title":"Bilinear terms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"EditURL = \"../../tutorials/Extension/typed.jl\"","category":"page"},{"location":"generated/Extension/typed/#Multivariate-polynomials-implementations","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"","category":"section"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"The SumOfSquares package is built on top of the MultivariatePolynomials abstract interface. DynamicPolynomials is an implementation of this abstract interface so it can be used with SumOfSquares. Moreover, any other implementation can be used as well. To illustrate, we solve of (Blekherman et al., 2012; Examples 3.38) with TypedPolynomials, another implementation of MultivariatePolynomials.","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"import TypedPolynomials\nTypedPolynomials.@polyvar x y\nusing SumOfSquares\nimport CSDP\nmodel = SOSModel(CSDP.Optimizer)\ncon_ref = @constraint(model, 2x^4 + 5y^4 - x^2*y^2 >= -2(x^3*y + x + 1))\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"We see that the problem is feasible. The Sum-of-Squares decomposition can be obtained as follows:","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"sos_decomposition(con_ref)","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"Why is there several implementations ? Depending in the use-case, one implementation may be more appropriate than another one. TypedPolynomials is faster than DynamicPolynomials but it requires new compilation whenever the list of variables changes. This means that TypedPolynomials is not appropriate when the number of variables is dynamic or too large. However, for a small number of variables, it can be faster. When solving Sum-of-Squares programs, the time is mostly taken by the Semidefinite programming solver. The time taken by SumOfSquares/JuMP/MathOptInterface are usually negligible or it time is taken by manipulation of JuMP or MathOptInterface functions therefore using TypedPolynomials over DynamicPolynomials may not make much difference in most cases.","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"One case for which using TypedPolynomials might be adequate is when using domain defined by equalities (possibly also with inequalities). Indeed, in that case, SumOfSquares computes the corresponding Gröbner basis which may take a non-negligible amount of time for large systems of equalities.","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"To illustrate this, consider the computation of Gröbner basis for the following system from [CLO05, p. 17]. The time taken by TypedPolynomials is below:","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"[CLO05] Cox, A. David & Little, John & O'Shea, Donal Using Algebraic Geometry. Graduate Texts in Mathematics, 2005. https://doi.org/10.1007/b138611","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"using BenchmarkTools\n@btime let\n    TypedPolynomials.@polyvar x y\n    S = @set x^3 * y + x == 2x^2 * y^2 && 3x^4 == y\n    SemialgebraicSets.compute_gröbner_basis!(S.I)\nend","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"The time taken by DynamicPolynomials is as follows:","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"import DynamicPolynomials\n@btime let\n    DynamicPolynomials.@polyvar x y\n    S = @set x^3 * y + x == 2x^2 * y^2 && 3x^4 == y\n    SemialgebraicSets.compute_gröbner_basis!(S.I)\nend","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"We see that TypedPolynomials is faster. The time is still negligible for this small system but for larger systems, choosing TypedPolynomials may be helpful. We can use this system in a Sum-of-Squares constraint as follows:","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"TypedPolynomials.@polyvar x y\nS = @set x^3 * y + x == 2x^2 * y^2 && 3x^4 == y\npoly = -6x - 4y^3 + 2x*y^2 + 6x^3 - 3y^4 + 13x^2 * y^2\nmodel = Model(CSDP.Optimizer)\ncon_ref = @constraint(model, poly in SOSCone(), domain = S)\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"We obtain the following decomposition:","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"dec = sos_decomposition(con_ref, 1e-6)","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"We can verify that it is correct as follows:","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"rem(dec - poly, S.I)","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"Note that the difference between dec and poly is larger than between the full gram matrix because dec is obtained by dropping the lowest eigenvalues with the threshold 1e-6; see sos_decomposition.","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"rem(gram_matrix(con_ref) - poly, S.I)","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"","category":"page"},{"location":"generated/Extension/typed/","page":"Multivariate polynomials implementations","title":"Multivariate polynomials implementations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"EditURL = \"../../tutorials/Polynomial Optimization/qcqp.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/#Nonconvex-quadratically-constrained-quadratic-programs","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"","category":"section"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"(Image: ) (Image: ) Adapted from: (Hesse, 1973), (Floudas et al., 1999; Section 3.4), (Laurent, 2008; Example 6.22) and (Lasserre, 2009; Table 5.1)","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"We consider the nonconvex Quadratically Constrained Quadratic Programs (QCQP) introduced in [H73]. Consider now the polynomial optimization problem (Laurent, 2008; Example 6.22) of maximizing the convex quadratic function (hence nonconvex since convex programs should either maximize concave functions or minimize convex functions) 25(x_1 - 2)^2 + (x_2 - 2)^2 + (x_3 - 1)^2 + (x_4 - 4)^2 + (x_5 - 1)^2 + (x_6 - 4)^2 over the basic semialgebraic set defined by the nonconvex quadratic inequalities (x_3 - 3)^2 + x_4 ge 4, (x_5 - 3)^2 + x_6 ge 4, and linear inequalities x_1 - 3x_2 le 2, -x_1 + x_2 le 2, 2 le x_1 + x_2 le 6, 0 le x_1 x_2, 1 le x_3 le 5, 0 le x_4 le 6, 1 le x_5 le 5, 0 le x_6 le 10, x_2 le 4x_1^4 - 32x_1^3 + 88x_1^2 - 96x_1 + 36 and the box constraints 0 le x_1 le 3 and 0 le x_2 le 4,","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"using DynamicPolynomials\n@polyvar x[1:6]\ncenters = [2, 2, 1, 4, 1, 4]\nweights = [25, 1, 1, 1, 1, 1]\np = -weights' * (x .- centers).^2\nusing SumOfSquares\nK = @set x[1] >= 0 && x[2] >= 0 &&\n    x[3] >= 1 && x[3] <= 5 &&\n    x[4] >= 0 && x[4] <= 6 &&\n    x[5] >= 1 && x[5] <= 5 &&\n    x[6] >= 0 && x[6] <= 10 &&\n    (x[3] - 3)^2 + x[4] >= 4 &&\n    (x[5] - 3)^2 + x[6] >= 4 &&\n    x[1] - 3x[2] <= 2 &&\n    -x[1] + x[2] <= 2 &&\n    x[1] + x[2] <= 6 &&\n    x[1] + x[2] >= 2","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"import Clarabel\nsolver = Clarabel.Optimizer","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following function searches for the largest lower bound and finds zero using the dth level of the hierarchy`.","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"function solve(d)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = K, maxdegree = d)\n    optimize!(model)\n    println(solution_summary(model))\n    return model\nend","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"The first level of the hierarchy cannot find any lower bound.","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"model2 = solve(2)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"The second level of the hierarchy finds the lower bound of -310.","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"model3 = solve(4)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"","category":"page"},{"location":"generated/Polynomial Optimization/qcqp/","page":"Nonconvex quadratically constrained quadratic programs","title":"Nonconvex quadratically constrained quadratic programs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"EditURL = \"../../tutorials/Polynomial Optimization/goldstein_price.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/#Goldstein-price-function","page":"Goldstein-price function","title":"Goldstein-price function","text":"","category":"section"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"In this example, we consider the minimization of the Goldstein-price function.","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"using SumOfSquares\nusing DynamicPolynomials","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"Create symbolic variables (not JuMP decision variables)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"@polyvar x[1:2]","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"To use Sum-of-Squares Programming, we first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"import Clarabel\nusing Dualization\nmodel = SOSModel(dual_optimizer(Clarabel.Optimizer))","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"Create a JuMP decision variable for the lower bound","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"@variable(model, γ)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"f(x) is the Goldstein-Price function","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"f1 = x[1] + x[2] + 1\nf2 = 19 - 14*x[1] + 3*x[1]^2 - 14*x[2] + 6*x[1]*x[2] + 3*x[2]^2\nf3 = 2*x[1] - 3*x[2]\nf4 = 18 - 32*x[1] + 12*x[1]^2 + 48*x[2] - 36*x[1]*x[2] + 27*x[2]^2\nf = (1 + f1^2*f2) * (30 + f3^2*f4)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"Constraints f(x) - γ to be a sum of squares","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"con_ref = @constraint(model, f >= γ)\n@objective(model, Max, γ)\noptimize!(model)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"The lower bound found is 3","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"solution_summary(model)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"The moment matrix is as follows, we can already see the global minimizer [0, -1] from the entries (2, 1) and (3, 1). This heuristic way to obtain solutions to the polynomial optimization problem is suggested in (Laurent, 2008; (6.15)).","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"ν = moment_matrix(con_ref)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"Many entries of the matrix actually have the same moment. We can obtain the following list of these moments without duplicates (ignoring when difference of entries representing the same moments is below 1e-5)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"μ = measure(ν, atol = 1e-5)","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"The truncated moment matrix can then be obtained as follows","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"ν_truncated = moment_matrix(μ, monomials(x, 0:3))","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"Let's check if the flatness property is satisfied. The rank of ν_truncated seems to be 1:","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"using LinearAlgebra\nLinearAlgebra.svdvals(Matrix(ν_truncated.Q))\nLinearAlgebra.rank(Matrix(ν_truncated.Q), rtol = 1e-3)\nsvdvals(Matrix(ν_truncated.Q))","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"The rank of ν is clearly higher than 1, closer to 3:","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"svdvals(Matrix(ν.Q))","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"Even if the flatness property is not satisfied, we can still try extracting the minimizer with a low rank decomposition of rank 3. We find the optimal solution again doing so:","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"atomic_measure(ν, FixedRank(3))","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"","category":"page"},{"location":"generated/Polynomial Optimization/goldstein_price/","page":"Goldstein-price function","title":"Goldstein-price function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"EditURL = \"../../tutorials/Getting started/sum-of-squares_matrices.jl\"","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/#Sum-of-Squares-matrices","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"","category":"section"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"(Image: ) (Image: ) Adapted from: (Blekherman et al., 2012; Examples 3.77)","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/#Introduction","page":"Sum-of-Squares matrices","title":"Introduction","text":"","category":"section"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"Consider the symmetric polynomial matrix P(x) = beginbmatrix     x^2 - 2x + 2  x\n    x             x^2 endbmatrix We could like to know whether P(x) is positive semidefinite for all x in mathbbR.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"using DynamicPolynomials\n@polyvar x\nP = [x^2 - 2x + 2 x\n            x     x^2]","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"A sufficient condition for a symmetric polynomial matrix P(x) to be positive semidefinite for all x is to the existence of a matrix M(x) such that P(x) = M^top(x) M(x). If such matrix M exists, we say that the matrix is an \\emph{sos matrix} (see [Definition 3.76, BPT13]). While determining whether P(x) is positive semidefinite for all x, is NP-hard (checking nonnegativity of a polynomial is reduced to this problem for 1 times 1 matrices), checking whether P(x) is an sos matrix is an sos program.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"using SumOfSquares","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"import CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\n\nmodel = SOSModel(solver)\nmat_cref = @constraint(model, P in PSDCone())\noptimize!(model)\ntermination_status(model)","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"While the reformulation of sos matrix to sos polynomial is rather simple, as explained in the \"Sum-of-Squares reformulation\" section below, there is a technical subtelty about the Newton polytope that if not handled correctly may result in an SDP of large size with bad numerical behavior. For this reason, it is recommended to model sos matrix constraints as such as will be shown in this notebook and not do the formulation manually unless there is a specific reason to do so.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"As we can verify as follows, only 3 monomials are used using the sos matrix constraint.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"certificate_monomials(mat_cref)","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/#Sum-of-Squares-reformulation","page":"Sum-of-Squares matrices","title":"Sum-of-Squares reformulation","text":"","category":"section"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"One way to obtain the reduction to an sos program is to create an intermediate vector of variable y and check whether the polynomial p(x y) = y^top P(x) y is sos. However, special care is required when approximating the Newton polytope of p(x y). Indeed, for instance if the entries of P(x) are quadratic forms then the Newton polytope of p(x y) is the cartesian product between the Newton polytope of y^top y and the Newton polytope of x^top x. In other words, p(x y) belongs to a family of quartic forms called biquadratic forms. This fact is important when generating the semidefinite program so that only bilinear monomials are used. So if the cheap outer approximation is used (instead of the exact polyhedral computation) for the newton polytope then it is important to use a multipartite computation approximation of the newton polytope. The multipartie exact approach may perform worse compared to the unipartite exact in certain cases though. Consider for instance the polynomial matrix mathrmDiag(x_1^1 x_2^2) for which p(x y) = x_1^2y_1^2 + x_2^2y_2^2. For this polynomial, only the monomials x_1y_1 and x_2y_2 are needed in the SDP reformulation while the multipartite approach, as it will compute the Newton polytope as a cartesian product, will not see the dependence between x and y in the presence of monomials and will also select the monomials x_1y_2 and x_2y_1.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"@polyvar y[1:2]\np = vec(y)' * P * vec(y)","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"We can see above that p is biquadratic polynomial in the variables x and y. Computing the Newton polytope with the cheap outer approximation without exploiting this multipartite structure gives the following 6 monomials.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"X = monomials(p)\nunipartite = Certificate.NewtonDegreeBounds(tuple())\nCertificate.monomials_half_newton_polytope(X, unipartite)","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"Exploiting the multipartite structure gives 4 monomials.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"multipartite = Certificate.NewtonDegreeBounds(([x], y))\nCertificate.monomials_half_newton_polytope(X, multipartite)","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"In the example above, there were only 3 monomials, where does the difference come from ? Using the monomial basis, the only product of two monomials that is equal to y[2]^2 is y[2] * y[2]. As y[2]^2 is not a monomial of p, we can conclude that the diagonal entry with row and column corresponding to y[2] will be zero hence the whole column and row will be zero as well. Therefore, we can remove this monomial.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"Certificate.monomials_half_newton_polytope(X, Certificate.NewtonFilter(multipartite))","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"The same reasoning can be used for monomials y[1]y[2] and x therefore whether we exploit the multipartite structure or not, we get only 3 monomials thanks to this post filter.","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"Certificate.monomials_half_newton_polytope(X, Certificate.NewtonFilter(unipartite))","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"","category":"page"},{"location":"generated/Getting started/sum-of-squares_matrices/","page":"Sum-of-Squares matrices","title":"Sum-of-Squares matrices","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sumofsquares/#Sum-of-Squares-Programming","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"This section contains a brief introduction to Sum-of-Squares Programming. For more details, see (Blekherman et al., 2012; Lasserre, 2009; Laurent, 2008).","category":"page"},{"location":"sumofsquares/#Quadratic-forms-and-Semidefinite-programming","page":"Sum-of-Squares Programming","title":"Quadratic forms and Semidefinite programming","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"The positive semidefiniteness of a n times n real symmetric matrix Q is equivalent to the nonnegativity of the quadratic form p(x) = x^top Q x for all vector x in mathbbR^n. For instance, the polynomial","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"x_1^2 + 2x_1x_2 + 5x_2^2 + 4x_2x_3 + x_3^2 = x^top beginpmatrix1  1  01  5  2 0  2  1endpmatrix x","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"is nonnegative since the matrix of the right-hand side is positive semidefinite. Moreover, a certificate of nonnegativity can be extracted from the Cholesky decomposition of the matrix:","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"(x_1 + x_2)^2 + (2x_2 + x_3)^2 = x^top beginpmatrix1  1  00  2  1endpmatrix^top beginpmatrix1  1  00  2  1endpmatrix x","category":"page"},{"location":"sumofsquares/#Polynomial-nonnegativity-and-Semidefinite-programming","page":"Sum-of-Squares Programming","title":"Polynomial nonnegativity and Semidefinite programming","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"This can be generalized to a polynomial of arbitrary degree. A polynomial p(x) is nonnegative if it can be rewritten as p(x) = X^top Q X where Q is a real symmetric positive semidefinite matrix and X is a vector of monomials.","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"For instance","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"x_1^2 + 2x_1^2x_2 + 5x_1^2x_2^2 + 4x_1x_2^2 + x_2^2 = X^top beginpmatrix1  1  01  5  2 0  2  1endpmatrix X","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"where X = (x_1 x_1x_2 x_2) Similarly to the previous section, the Cholesky factorization of the matrix can be used to extract a sum of squares certificate of nonnegativity for the polynomial:","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"(x_1 + x_1x_2)^2 + (2x_1x_2 + x_2)^2 = X^top beginpmatrix1  1  00  2  1endpmatrix^top beginpmatrix1  1  00  2  1endpmatrix X","category":"page"},{"location":"sumofsquares/#When-is-nonnegativity-equivalent-to-sum-of-squares-?","page":"Sum-of-Squares Programming","title":"When is nonnegativity equivalent to sum of squares ?","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"Determining whether a polynomial is nonnegative is NP-hard. The condition of the previous section was only sufficient, that is, there exists nonnegative polynomials that are not sums of squares. Hilbert showed in 1888 that there are exactly 3 cases for which there is equivalence between the nonnegativity of the polynomials of n variables and degree 2d and the existence of a sum of squares decomposition.","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"n = 1 : Univariate polynomials\n2d = 2 : Quadratic polynomials\nn = 2, 2d = 4 : Bivariate quartics","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"The first explicit example of polynomial that was not a sum of squares was given by Motzkin in 1967:","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"x_1^4x_2^2 + x_1^2x_2^4 + 1 - 3x_1^2x_2^2 geq 0 quad forall x","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"While it is not a sum of squares, it can still be certified to be nonnegative using sum-of-squares programming by identifying it with a rational sum-of-squares decomposition. These facts can be verified numerically using this package as detailed in the Motzkin example.","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"EditURL = \"../../tutorials/Getting started/getting_started.jl\"","category":"page"},{"location":"generated/Getting started/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO1 (See Section 4.1 of SOSTOOLS User's Manual) and Example 2.4 of [PJ08]","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"P. Parrilo and A. Jadbabaie Approximation of the joint spectral radius using sum of squares. Linear Algebra and its Applications, Elsevier (2008), 428, 2385-2402","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"using DynamicPolynomials\n@polyvar x y\np = 2*x^4 + 2*x^3*y - x^2*y^2 + 5*y^4","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"using SumOfSquares\nimport CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver)\ncon_ref = @constraint(model, p >= 0)\noptimize!(model)\nprimal_status(model)","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"We see above that the solver found a feasible solution. We now inspect this solution:","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"q = gram_matrix(con_ref)","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"We can get the SOS decomposition from the gram matrix as follows:","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"sosdec = SOSDecomposition(q)","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"We now seek for the SOS decomposition of the following polynomial:","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"p = 4*x^4*y^6 + x^2 - x*y^2 + y^2","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"We build the same model as previously with this new polynomial. Here we can use Model instead of SOSModel as we explicitly constrain p to belong to the SOS cone with p in SOSCone().","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"model = Model(solver)\ncon_ref = @constraint(model, p in SOSCone())\noptimize!(model)\nprimal_status(model)","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"We can query the SOS decomposition directly from the constraint reference as follows:","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"sos_decomposition(con_ref)","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"generated/Getting started/getting_started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/#Equality-constraints-between-polynomials","page":"Constraints","title":"Equality constraints between polynomials","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Equality between polynomials in PolyJuMP uses the same syntax as equality between affine or quadratic expression in JuMP. For instance, creating two quadratic n-variate polynomials p and q that must sum up to one can be done as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> n = 3\n3\n\njulia> using DynamicPolynomials\n\njulia> @polyvar x[1:n]\n(Variable{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}[x₁, x₂, x₃],)\n\njulia> X = monomials(x, 0:2)\n10-element MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}:\n 1\n x₃\n x₂\n x₁\n x₃²\n x₂x₃\n x₂²\n x₁x₃\n x₁x₂\n x₁²\n\njulia> using SumOfSquares\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, p, Poly(X))\n(_[1]) + (_[2])x₃ + (_[3])x₂ + (_[4])x₁ + (_[5])x₃² + (_[6])x₂x₃ + (_[7])x₂² + (_[8])x₁x₃ + (_[9])x₁x₂ + (_[10])x₁²\n\njulia> @variable(model, q, Poly(X))\n(_[11]) + (_[12])x₃ + (_[13])x₂ + (_[14])x₁ + (_[15])x₃² + (_[16])x₂x₃ + (_[17])x₂² + (_[18])x₁x₃ + (_[19])x₁x₂ + (_[20])x₁²\n\njulia> @constraint(model, p + q == 1)\n(_[1] + _[11] - 1) + (_[2] + _[12])x₃ + (_[3] + _[13])x₂ + (_[4] + _[14])x₁ + (_[5] + _[15])x₃² + (_[6] + _[16])x₂x₃ + (_[7] + _[17])x₂² + (_[8] + _[18])x₁x₃ + (_[9] + _[19])x₁x₂ + (_[10] + _[20])x₁² ∈ PolyJuMP.ZeroPoly()","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Vectorized constraints can also be used as well as vector of constraints, named constraints, ... For instance, if P and Q are two n times n matrices of polynomials, the following constraints the sum of rows and columns to match:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"@constraint(model, con[i=1:n], sum(P[i, :]) == sum(Q[:, i]))","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"and con[i] contains the reference to the constraint between the ith row of P and the ith column of Q.","category":"page"},{"location":"constraints/#Inequality-constraints-between-polynomials","page":"Constraints","title":"Inequality constraints between polynomials","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Polynomials can be constrained to be sum-of-squares with the in syntax. For instance, to constrain a polynomial p to be sum-of-squares, do","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, p in SOSCone())\n(_[1]) + (_[2])x₃ + (_[3])x₂ + (_[4])x₁ + (_[5])x₃² + (_[6])x₂x₃ + (_[7])x₂² + (_[8])x₁x₃ + (_[9])x₁x₂ + (_[10])x₁² is SOS","category":"page"},{"location":"constraints/#Automatically-interpreting-polynomial-nonnegativity-as-a-sum-of-squares-constraint","page":"Constraints","title":"Automatically interpreting polynomial nonnegativity as a sum-of-squares constraint","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As detailed in When is nonnegativity equivalent to sum of squares ?, the nonnegativity of a polynomial is not equivalent to the existence of a sum-of-squares decomposition. However, if explicitely specified, nonnegativity constraints can be automatically interpreted as sum-of-squares constraints. The simplest way to do that is to create the model with","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"model = SOSModel(...)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"instead of","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"model = Model(...)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"An alternative equivalent way is to call setpolymodule! after creating the model:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> setpolymodule!(model, SumOfSquares)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This second approach may be useful if the SumOfSquares JuMP extension need to be used with another JuMP extension that also has a special model constructor. A third alternative is the following:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> PolyJuMP.setdefault!(model, PolyJuMP.NonNegPoly, SOSCone)\nSOSCone (alias for NonnegPolyInnerCone{MathOptInterface.PositiveSemidefiniteConeTriangle})\n\njulia> PolyJuMP.setdefault!(model, PolyJuMP.PosDefPolyMatrix, SOSMatrixCone)\nSOSMatrixCone (alias for PSDMatrixInnerCone{MathOptInterface.PositiveSemidefiniteConeTriangle})","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This approach adds the flexibility to choose the default cone for","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraints of the form @constraint(mode, ..., some_polynomial ≥ other_polynomial, ...) which is the cone given as default to PolyJuMP.NonNegPoly; and\nconstraints of the form @constraint(mode, ..., some_matrix_of_polynomial in PSDCone(), ...) or @constraint(mode, ..., some_matrix_of_polynomial >= other_matrix_of_polynomial, PSDCone(), ...) which is the cone given as default to PolyJuMP.NonNegPolyMatrix.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"For instance, to use the diagonally-dominant-sum-of-squares cone (see (Ahmadi and Majumdar, 2017; Definition 2)) for the first type of contraints, do","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> PolyJuMP.setdefault!(model, PolyJuMP.NonNegPoly, DSOSCone)\nDSOSCone (alias for NonnegPolyInnerCone{SumOfSquares.DiagonallyDominantConeTriangle})","category":"page"},{"location":"constraints/#Changing-the-polynomial-basis","page":"Constraints","title":"Changing the polynomial basis","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As introduced in Choosing a polynomial basis, there may be numerical advantages to use another basis than the standard monomial basis when creating polynomial variables. Similarly, other polynomial bases can be used for polynomial constraints. However, for constraints, the polynomial space is determined by the polynomial constrained to be nonnegative. For instance, consider the constraint:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> using DynamicPolynomials\n\njulia> @polyvar x y\n(x, y)\n\njulia> using SumOfSquares\n\njulia> model = SOSModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, α)\nα\n\njulia> @variable(model, β)\nβ\n\njulia> @constraint(model, α * x^2 + β * y^2 ≥ (α - β) * x * y)\n(β)y² + (-α + β)xy + (α)x² is SOS","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"where α and β are JuMP decision variables and x and y are polynomial variables. Since the polynomial is a quadratic form, the sum-of-squares certificate is also a quadratic form (see (Blekherman et al., 2012; Section~3.3.4)). Hence the default polynomial basis used for the [Nonnegative polynomial variables] certificate is MonomialBasis([x, y]), that is, we search for a positive semidefinite matrix Q such that","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"alpha x^2 + beta y^2 - (alpha - beta) x y = X^top Q X","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"where X = (x y).","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As the polynomial space is determined by the polynomial being constrained, only the basis type needs to be given. For instance, to use the scaled monomial basis in the example above, use","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, α * x^2 + β * y^2 ≥ (α - β) * x * y, basis = ScaledMonomialBasis)\n(β)y² + (-α + β)xy + (α)x² is SOS","category":"page"},{"location":"constraints/#Polynomial-nonnegativity-on-a-subset-of-the-space","page":"Constraints","title":"Polynomial nonnegativity on a subset of the space","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"By default, the constraint","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x^3 - x^2 + 2x*y -y^2 + y^3 >= α)\n(-α) + (-1)y² + (2)xy + (-1)x² + (1)y³ + (1)x³ is SOS","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constrains the polynomial to be nonnegative for every real numbers x and y. However, the set of points (x, y) for which the polynomial is constrained to be nonnegative can be specified by the domain keyword:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> S = @set x >= 0 && y >= 0 && x + y >= 1;\n\njulia> @constraint(model, x^3 - x^2 + 2x*y -y^2 + y^3 >= α, domain = S)\n(-α) + (-1)y² + (2)xy + (-1)x² + (1)y³ + (1)x³ is SOS","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See this notebook for a detailed example.","category":"page"},{"location":"constraints/#Dual-of-polynomial-constraints","page":"Constraints","title":"Dual of polynomial constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The dual of a polynomial constraint cref is a moment serie μ as defined in MultivariateMoments. The dual can be obtained with the dual function as with classical dual values in JuMP.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"μ = dual(cref)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"By dual of a Sum-of-Squares constraint, we may mean different things and the meaning chosen for dual function was chosen for consistency with the definition of the JuMP dual function to ensure that generic code will work as expected with Sum-of-Squares constraints. In a Sum-of-Squares constraint, a polynomial p is constraint to be SOS in some domain defined by polynomial q_i. So p(x) is constrained to be equal to s(x) = s_0(x) + s_1(x) * q_1(x) + s_2(x) * q_2(x) + ... where the s_i(x) polynomials are Sum-of-Squares. The dual of the equality constraint between p(x) and s(x) is given by SumOfSquares.MultivariateMoments.moments.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"μ = moments(cref)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that the dual and moments may give different results. For instance, the output of dual only contains the moments corresponding to monomials of p while the output of moments may give the  moments of other monomials if s(x) has more monomials than p(x). Besides, if the domain contains polynomial, equalities, only the  remainder of p(x) - s(x) modulo the ideal is constrained to be zero, see Corollary 2 of (Cox et al., 2015). In that case, the output moments is the dual of the constraint on the remainder so some monomials may have different moments with dual or moments.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The dual of the Sum-of-Squares constraint on s_0(x), commonly referred to as the the matrix of moments can be obtained using moment_matrix:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"ν = moment_matrix(cref)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The atomic_measure function of MultivariateMoments can be used to check if there exists an atomic measure (i.e. a measure that is a sum of Dirac measures) that has the moments given in the the moment matrix ν. This can be used for instance in polynomial optimization (see this notebook) or stability analysis (see this notebook).","category":"page"},{"location":"constraints/#SAGE-extension","page":"Constraints","title":"SAGE extension","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"To use the SAGE cone in place of the Sum-of-Squares cone for an inequality constraints between polynomials, use the following:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"import PolyJuMP\nPolyJuMP.setpolymodule!(model, PolyJuMP.SAGE)","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"EditURL = \"../../tutorials/Extension/certificate.jl\"","category":"page"},{"location":"generated/Extension/certificate/#Certificate","page":"Certificate","title":"Certificate","text":"","category":"section"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Extension/certificate/#Introduction","page":"Certificate","title":"Introduction","text":"","category":"section"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"Consider the polynomial optimization problem (a variation from (Lasserre, 2009; Example 2.2)) of minimizing the polynomial x^3 - x^2 + 2xy - y^2 + y^3 over the polyhedron defined by the inequalities x ge 0 y ge 0 and x + y geq 1.","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"using DynamicPolynomials\n@polyvar x y\np = x^3 - x^2 + 2x*y - y^2 + y^3 + x^3 * y\nusing SumOfSquares\nS = @set x >= 0 && y >= 0 && x^2 + y^2 >= 2","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices. Note that SumOfSquares generates a standard form SDP (i.e., SDP variables and equality constraints) while SCS expects a geometric form SDP (i.e., free variables and symmetric matrices depending affinely on these variables constrained to belong to the PSD cone). JuMP will transform the standard from to the geometric form will create the PSD variables as free variables and then constrain then to be PSD. While this will work, since the dual of a standard from is in in geometric form, dualizing the problem will generate a smaller SDP. We use therefore Dualization.dual_optimizer so that SCS solves the dual problem.","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"import SCS\nusing Dualization\nsolver = dual_optimizer(SCS.Optimizer)","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following program searches for the largest lower bound.","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"model = SOSModel(solver)\n@variable(model, α)\n@objective(model, Max, α)\n@constraint(model, c, p >= α, domain = S)\noptimize!(model)","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"We can see that the problem is infeasible, meaning that no lower bound was found.","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"solution_summary(model)","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"We now define the Schmüdgen's certificate:","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"import MultivariateBases as MB\nconst SOS = SumOfSquares\nconst SOSC = SOS.Certificate\nstruct Schmüdgen{IC <: SOSC.AbstractIdealCertificate, CT <: SOS.SOSLikeCone, BT <: SOS.AbstractPolynomialBasis} <: SOSC.AbstractPreorderCertificate\n    ideal_certificate::IC\n    cone::CT\n    basis::Type{BT}\n    maxdegree::Int\nend\n\nSOSC.cone(certificate::Schmüdgen) = certificate.cone\n\nfunction SOSC.preprocessed_domain(::Schmüdgen, domain::BasicSemialgebraicSet, p)\n    return SOSC.with_variables(domain, p)\nend\n\nfunction SOSC.preorder_indices(::Schmüdgen, domain::SOSC.WithVariables)\n    n = length(domain.inner.p)\n    if n >= Sys.WORD_SIZE\n        error(\"There are $(2^n - 1) products in Schmüdgen's certificate, they cannot even be indexed with `$Int`.\")\n    end\n    return map(SOSC.PreorderIndex, 1:(2^n-1))\nend\n\nfunction SOSC.multiplier_basis(certificate::Schmüdgen, index::SOSC.PreorderIndex, domain::SOSC.WithVariables)\n    q = SOSC.generator(certificate, index, domain)\n    return SOSC.maxdegree_gram_basis(certificate.basis, variables(domain), SOSC.multiplier_maxdegree(certificate.maxdegree, q))\nend\nfunction SOSC.multiplier_basis_type(::Type{Schmüdgen{IC, CT, BT}}) where {IC, CT, BT}\n    return BT\nend\n\nfunction SOSC.generator(::Schmüdgen, index::SOSC.PreorderIndex, domain::SOSC.WithVariables)\n    I = [i for i in eachindex(domain.inner.p) if !iszero(index.value & (1 << (i - 1)))]\n    return prod([domain.inner.p[i] for i in eachindex(domain.inner.p) if !iszero(index.value & (1 << (i - 1)))])\nend\n\nSOSC.ideal_certificate(certificate::Schmüdgen) = certificate.ideal_certificate\nSOSC.ideal_certificate(::Type{<:Schmüdgen{IC}}) where {IC} = IC\n\nSOS.matrix_cone_type(::Type{<:Schmüdgen{IC, CT}}) where {IC, CT} = SOS.matrix_cone_type(CT)","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"Let's try again with our the Schmüdgen certificate:","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"model = SOSModel(solver)\n@variable(model, α)\n@objective(model, Max, α)\nideal_certificate = SOSC.Newton(SOSCone(), MB.MonomialBasis, tuple())\ncertificate = Schmüdgen(ideal_certificate, SOSCone(), MB.MonomialBasis, maxdegree(p))\n@constraint(model, c, p >= α, domain = S, certificate = certificate)\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"","category":"page"},{"location":"generated/Extension/certificate/","page":"Certificate","title":"Certificate","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"EditURL = \"../../tutorials/Getting started/motzkin.jl\"","category":"page"},{"location":"generated/Getting started/motzkin/#Motzkin","page":"Motzkin","title":"Motzkin","text":"","category":"section"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"(Image: ) (Image: ) Adapted from: (Blekherman et al., 2012; (3.6) and (3.19))","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"The first explicit example of nonnegative polynomial that is not a sum of squares was found by Motzkin in 1967. By the Arithmetic-geometric mean, $ \\frac{x^4y^2 + x^2y^4 + 1}{3} \\ge \\sqrt[3]{x^4y^2 \\cdot x^2y^4 \\cdot 1} = x^2y^2 $ hence $ x^4y^2 + x^2y^4 + 1 - 3x^2y^2 \\ge 0. $ The code belows construct the Motzkin polynomial using DynamicPolynomials.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"using DynamicPolynomials\n@polyvar x y\nmotzkin = x^4*y^2 + x^2*y^4 + 1 - 3x^2*y^2","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"The Motzkin polynomial is nonnegative but is not a sum of squares as we can verify numerically as follows. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"using SumOfSquares\nimport CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver)\n@constraint(model, motzkin >= 0) # We constraint `motzkin` to be a sum of squares\n\noptimize!(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"We see that the problem is detected as infeasible...","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"termination_status(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"... and that the dual solution is a certificate of the infeasibility of the problem.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"dual_status(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"Even if the Motzkin polynomial is not a sum of squares, it can still be certified to be nonnegative using sums of squares. Indeed a polynomial is certified to be nonnegative if it is equal to a fraction of sums of squares. The Motzkin polynomial is equal to a fraction of sums of squares whose denominator is x^2 + y^2. This can be verified numerically as follows:","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"model = SOSModel(solver)\n@constraint(model, (x^2 + y^2) * motzkin >= 0) # We constraint the `(x^2 + y^2) * motzkin` to be a sum of squares\n\noptimize!(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"Now the problem is declared feasible by the solver...","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"termination_status(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"... and the primal solution is a feasible point, hence it is a certificate of nonnegativity of the Motzkin polynomial.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"primal_status(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"One may consider ourself lucky to have had the intuition that x^2 + y^2 would work as denominator. In fact, the search for the denominator can be carried out in parallel to the search of the numerator. In the example below, we search for a denominator with monomials of degrees from 0 to 2. If none is found, we can increase the maximum degree 2 to 4, 6, 8, ... This gives a hierarchy of programs to try in order to certify the nonnegativity of a polynomial by identifying it with a fraction of sum of squares polynomials. In the case of the Motzkin polynomial we now that degree 2 is enough since x^2 + y^2 works.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"model = SOSModel(solver)\nX = monomials([x, y], 0:2)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"We create a quadratic polynomial that is not necessarily a sum of squares since this is implied by the next constraint: deno >= 1.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"@variable(model, deno, Poly(X))","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"We want the denominator polynomial to be strictly positive, this prevents the trivial solution deno = 0 for instance.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"@constraint(model, deno >= 1)\n@constraint(model, deno * motzkin >= 0)\noptimize!(model)\n\ntermination_status(model)\n\nprimal_status(model)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"We can check the denominator found by the program using JuMP.value","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"value(deno)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"Because a picture is worth a thousand words let's plot the beast. We can easily extend Plots by adding a recipe to plot bivariate polynomials.","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"using RecipesBase\n@recipe function f(x::AbstractVector, y::AbstractVector, p::Polynomial)\n    x, y, (x, y) -> p(variables(p) => [x, y])\nend\nimport Plots\nPlots.plot(\n    range(-2, stop=2, length=100),\n    range(-2, stop=2, length=100),\n    motzkin,\n    st = [:surface],\n    seriescolor=:heat,\n    colorbar=:none,\n    clims = (-10, 80)\n)","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"","category":"page"},{"location":"generated/Getting started/motzkin/","page":"Motzkin","title":"Motzkin","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"EditURL = \"../../tutorials/Getting started/univariate.jl\"","category":"page"},{"location":"generated/Getting started/univariate/#Minimization-of-a-univariate-polynomial","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"","category":"section"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"using DynamicPolynomials\nusing SumOfSquares\nimport CSDP","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Consider the problem of finding both the minimum value of p = x^4 - 4x^3 - 2x^2 + 12x + 3 as well as its minimizers.","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"We can use SumOfSquares.jl to find such these values as follows. We first define the polynomial using DynamicPolynomials.","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"@polyvar x\np = x^4 - 4x^3 - 2x^2 + 12x + 3","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Secondly, we create a Sum-of-Squares program searching for the maximal lower bound σ of the polynomial.","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"model = SOSModel(CSDP.Optimizer)\n@variable(model, σ)\n@constraint(model, cref, p >= σ)\n@objective(model, Max, σ)","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Thirdly, solve the program and find σ = -6 as lower bound:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"optimize!(model)\nsolution_summary(model)","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"We can look at the certificate that σ = -6 is a lower bound:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"sos_dec = sos_decomposition(cref, 1e-4)","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Indeed, p + 6 = (x^2 - 2x - 3)^2 so p ≥ -6.","category":"page"},{"location":"generated/Getting started/univariate/#Extraction-of-minimizers","page":"Minimization of a univariate polynomial","title":"Extraction of minimizers","text":"","category":"section"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"We can now find the minimizers from the moment matrix:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"ν = moment_matrix(cref)\nν.Q","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"This matrix is the convex combination of the moment matrices corresponding to two atomic measures at -1 and 3 which allows us to conclude that -1 and 3 are global minimizers.","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"η = atomic_measure(ν, 1e-4)\nminimizers = [η.atoms[1].center; η.atoms[2].center]","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Below are more details on what we mean by convex combination. The moment matrix of the atomic measure at the first minimizer is:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"η1 = moment_matrix(dirac(monomials(x, 0:4), x => round(minimizers[1])), ν.basis.monomials)\nη1.Q","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"The moment matrix of the atomic measure at the second minimizer is:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"η2 = moment_matrix(dirac(monomials(x, 0:4), x => round(minimizers[2])), ν.basis.monomials)\nη2.Q","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"And the moment matrix is the convex combination of both:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Q12 = η1.Q * η.atoms[1].weight + η2.Q * η.atoms[2].weight","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Another way to see this (by linearity of the expectation) is that ν is the moment matrix of the convex combination of the two atomic measures.","category":"page"},{"location":"generated/Getting started/univariate/#Changing-the-polynomial-basis","page":"Minimization of a univariate polynomial","title":"Changing the polynomial basis","text":"","category":"section"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"The monomial basis used by default can leave a problem quite ill-conditioned for the solver. Let's try to use another basis instead:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"model = SOSModel(CSDP.Optimizer)\n@variable(model, σ)\n@constraint(model, cheby_cref, p >= σ, basis = ChebyshevBasisFirstKind)\n@objective(model, Max, σ)\noptimize!(model)\nsolution_summary(model)","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"Although the gram matrix in the monomial basis:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"g = gram_matrix(cref)\n@show g.basis\ng.Q","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"looks different from the gram matrix in the Chebyshev basis:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"cheby_g = gram_matrix(cheby_cref)\n@show cheby_g.basis\ncheby_g.Q","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"they both yields the same Sum-of-Squares decomposition:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"cheby_sos_dec = sos_decomposition(cheby_cref, 1e-4)","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"The gram matrix in the Chebyshev basis can be understood as follows. To express the polynomial -x^2 + 2x + 3 in the Chebyshev basis, we start by  substituting x into cos(theta) to obtain -cos(theta)^2 + 2cos(theta) + 3. We now express it as a combination of cos(ntheta) for n = 0 1 2: -(2cos(theta) - 1) 2 + 2 cos(theta) + 52 Therefore, the coefficients in the Chebyshev basis is:","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"cheby_coefs = [5/2, 2, -1/2]","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"We can indeed observe that we obtain the same matrix as cheby_g.Q","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"cheby_coefs * cheby_coefs'","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"","category":"page"},{"location":"generated/Getting started/univariate/","page":"Minimization of a univariate polynomial","title":"Minimization of a univariate polynomial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"EditURL = \"../../tutorials/Other Applications/bounds_in_probability.jl\"","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/#Bounds-in-Probability","page":"Bounds in Probability","title":"Bounds in Probability","text":"","category":"section"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO8 (See Section 4.8 of SOSTOOLS User's Manual)","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The probability adds up to one.","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"μ0 = 1","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The mean is one.","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"μ1  = 1","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The standard deviation is 1/2.","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"σ = 1/2","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The second moment E(x^2) is:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"μ2 = σ^2 + μ1^2","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"We define the moments as follows:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"using DynamicPolynomials\n@polyvar x\nmonos = [1, x, x^2]\nusing SumOfSquares\nμ = measure([μ0, μ1, μ2], monos)","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"using CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver);\nnothing #hide","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"We create a polynomial with the monomials in monos and JuMP decision variables as coefficients as follows:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"@variable(model, poly, Poly(monos))","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"Nonnegative on the support:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"K = @set 0 <= x && x <= 5\ncon_ref = @constraint(model, poly >= 0, domain = K)","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"Greater than one on the event:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"@constraint(model, poly >= 1, domain = (@set 4 <= x && x <= 5))","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The bound (we use LinearAlgebra for the ⋅ syntax for the scalar product):","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"using LinearAlgebra\n@objective(model, Min, poly ⋅ μ)","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"We verify that we found a feasible solution:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"optimize!(model)\nprimal_status(model)","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The objective value is 1/37:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"objective_value(model)","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"The solution is (12x-11)^2 / 37^2:","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"value(poly) * 37^2","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"","category":"page"},{"location":"generated/Other Applications/bounds_in_probability/","page":"Bounds in Probability","title":"Bounds in Probability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"EditURL = \"../../tutorials/Extension/hypercube.jl\"","category":"page"},{"location":"generated/Extension/hypercube/#Hypercube","page":"Hypercube","title":"Hypercube","text":"","category":"section"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"Given a Sum-of-Squares constraint on an algebraic set:","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"g_1(x) =  ldots g_m(x) = 0 Rightarrow p(x) ge 0","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"We can either use the certificate:","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"p(x) = s(x) + lambda_1(x) g_1(x) + cdots + lambda_m(x) g_m(x) s_0(x) text is SOS","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"or","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"p(x) equiv s(x) pmodla g_1(x) ldots g_m(x) ra s_0(x) text is SOS","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"the second one leads to a simpler SDP but needs to compute a Gr\\\"obner basis:","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"SemialgebraicSets implements Buchberger's algorithm.\nThe @set macro recognizes variable fix, e.g., x = 1  and provides shortcut.\nIf you know a \\alert{better} way to take modulo, better create your \\alert{own} type of algebraic set!","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"We illustrate this in this example.","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"using DynamicPolynomials\n@polyvar x[1:3]\np = sum(x)^2\nusing SumOfSquares\nS = algebraicset([xi^2 - 1 for xi in x])","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"We will now search for the minimum of x over S using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"import CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\n\nfunction min_algebraic(S)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = S)\n    optimize!(model)\n    @show termination_status(model)\n    @show objective_value(model)\nend\n\nmin_algebraic(S)","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"Note that the minimum is in fact 1. Indeed, since each variables is odd (it is either -1 or 1) and there is an odd number of variables, their sum is odd. Therefore it cannot be zero!","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"We can see that the Gröbner basis of S was computed","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"@show S.I.gröbner_basis\nS.I.algo","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"The Gröbner basis is simple to compute in this case as the vector of xi^2 - 1 is already a Gröbner basis. However, we still need to divide polynomials by the Gröbner basis which can be simplified in this case.","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"const MP = MultivariatePolynomials\nconst SS = SemialgebraicSets\nstruct HypercubeIdeal{V} <: SS.AbstractPolynomialIdeal\n    variables::Vector{V}\nend\nstruct HypercubeSet{V} <: SS.AbstractAlgebraicSet\n    ideal::HypercubeIdeal{V}\nend\nMP.variables(set::HypercubeSet) = MP.variables(set.ideal)\nMP.variables(ideal::HypercubeIdeal) = ideal.variables\nBase.similar(set::HypercubeSet, ::Type) = set\nSS.ideal(set::HypercubeSet) = set.ideal\nfunction Base.rem(p, set::HypercubeIdeal)\n    return MP.polynomial(map(MP.terms(p)) do term\n        mono = MP.monomial(term)\n        new_mono = one(mono)\n        for (var, exp) in powers(mono)\n            if var in set.variables\n                exp = rem(exp, 2)\n            end\n            new_mono *= var^exp\n        end\n        MP.coefficient(term) * new_mono\n    end)\nend\n\nH = HypercubeSet(HypercubeIdeal(x))\n\nmin_algebraic(H)","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"Let's now try to find the correct lower bound:","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"function min_algebraic_rational(S, d)\n    model = SOSModel(solver)\n    @variable(model, q, SOSPoly(MP.monomials(x, 0:d)))\n    deno = q + 1\n    @constraint(model, c, deno * p >= deno, domain = S)\n    optimize!(model)\n    @show termination_status(model)\nend","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"With d = 0, it's the same as previously","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"min_algebraic_rational(H, 0)","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"But with d = 1, we can find the correct lower bound","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"min_algebraic_rational(H, 1)","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"","category":"page"},{"location":"generated/Extension/hypercube/","page":"Hypercube","title":"Hypercube","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"EditURL = \"../../tutorials/Polynomial Optimization/qp.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/qp/#Nonconvex-QP","page":"Nonconvex QP","title":"Nonconvex QP","text":"","category":"section"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"(Image: ) (Image: ) Adapted from:  of (Floudas et al., 1999; Section 2.2), (Lasserre, 2009; Table 5.1)","category":"page"},{"location":"generated/Polynomial Optimization/qp/#Introduction","page":"Nonconvex QP","title":"Introduction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"Consider the nonconvex Quadratic Program (QP) from (Floudas et al., 1999; Section 2.2) that minimizes the concave function c^top x - x^top Qx  2 over the polyhedron obtained by intersecting the hypercube 0 1^5 with the halfspace 10x_1 + 12x_2 + 11x_3 + 7x_4 + 4x_5 le 40.","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"using LinearAlgebra\nc = [42, 44, 45, 47, 47.5]\nQ = 100I\n\nusing DynamicPolynomials\n@polyvar x[1:5]\np = c'x - x' * Q * x / 2\nusing SumOfSquares\nK = @set x[1] >= 0 && x[1] <= 1 &&\n         x[2] >= 0 && x[2] <= 1 &&\n         x[3] >= 0 && x[3] <= 1 &&\n         x[4] >= 0 && x[4] <= 1 &&\n         x[5] >= 0 && x[5] <= 1 &&\n         10x[1] + 12x[2] + 11x[3] + 7x[4] + 4x[5] <= 40","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"import Clarabel\nsolver = Clarabel.Optimizer","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following function searches for the largest lower bound and finds zero using the dth level of the hierarchy`.","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"function solve(d)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = K, maxdegree = d)\n    optimize!(model)\n    println(solution_summary(model))\n    return model\nend","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"The first level of the hierarchy does not give any lower bound:","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"model2 = solve(2)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"Indeed, as the constraints have degree 1 and their multipliers are SOS so they have an even degree, with maxdegree 2 we can only use degree 0 multipliers hence constants. The terms of maximal degree in resulting sum will therefore only be in -x' * Q * x/2 hence it is not SOS whatever is the value of the multipliers. Let's try with maxdegree 3 so that the multipliers can be quadratic. This second level is now feasible and gives a lower bound of -22.","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"model3 = solve(3)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"","category":"page"},{"location":"generated/Polynomial Optimization/qp/","page":"Nonconvex QP","title":"Nonconvex QP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/certificate/#Certificate","page":"Certificate","title":"Certificate","text":"","category":"section"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"Default choice for the maxdegree keyword:","category":"page"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"SumOfSquares.default_maxdegree","category":"page"},{"location":"reference/certificate/#SumOfSquares.default_maxdegree","page":"Certificate","title":"SumOfSquares.default_maxdegree","text":"default_maxdegree(monos, domain)\n\nReturn the default maxdegree to use for certifying a polynomial with monomials monos to be Sum-of-Squares over the domain domain. By default, the maximum of the maxdegree of monos and of all multipliers of the domain are used so that at least constant multipliers can be used with a Putinar certificate.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"Types of sparsity","category":"page"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"SumOfSquares.Certificate.Sparsity.Variable\nSumOfSquares.Certificate.Sparsity.Monomial\nSumOfSquares.Certificate.Sparsity.SignSymmetry\nSumOfSquares.Certificate.Sparsity.XORSpace","category":"page"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.Variable","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.Variable","text":"struct Sparsity.Variable <: Sparsity.Pattern end\n\nVariable or correlative sparsity as developed in [WSMM06].\n\n[WSMM06] Waki, Hayato, Sunyoung Kim, Masakazu Kojima, and Masakazu Muramatsu. \"Sums of squares and semidefinite program relaxations for polynomial optimization problems with structured sparsity.\" SIAM Journal on Optimization 17, no. 1 (2006): 218-242.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.Monomial","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.Monomial","text":"struct Sparsity.Monomial{C<:CEG.AbstractCompletion} <: Sparsity.Pattern\n    completion::C\n    k::Int\n    use_all_monomials::Bool\nend\n\nMonomial or term sparsity as developed in [WML20a, WML20b]. The completion field should be ClusterCompletion() [default] for the block-closure or cluster completion [WML20a], and ChordalCompletion() for chordal completion [WML20b]. The integer k [default=0] corresponds to Σ_k defined in [(3.2), WML20a] and k = 0 corresponds to Σ_* defined in [(3.3), WML20a]. If use_all_monomials is false then some monomials of the basis might be dropped from the basis if not needed.\n\n[WML20a] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. TSSOS: A Moment-SOS hierarchy that exploits term sparsity. arXiv preprint arXiv:1912.08899 (2020).\n\n[WML20b] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. Chordal-TSSOS: a moment-SOS hierarchy that exploits term sparsity with chordal extension. arXiv preprint arXiv:2003.03210 (2020).\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.SignSymmetry","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.SignSymmetry","text":"struct SignSymmetry <: Sparsity.Pattern end\n\nSign symmetry as developed in [Section III.C, L09]. Let n be the number of variables. A sign-symmetry is a binary vector r of {0, 1}^n such that dot(r, e) is even for all exponent e.\n\nLet o(e) be the binary vector of {0, 1}^n for which the ith bit is i iff the ith entry of e is odd. Let O be the set of o(e) for exponents of e. A binary vector r is a sign-symmetry if an only if it is orthogonal to all the elements of O.\n\nSince we are only interested in the orthogonal subspace, say R, of O, even if O is not a linear subspace (i.e., it is not invariant under xor), we compute its span. We start by creating row echelon form of the span of O using XORSpace. We then compute a basis for R. The set R of sign symmetries will be the span of this basis.\n\nLet a, b be exponents of monomials of the gram basis. For any r in R,\n\n⟨r, o(a + b)⟩ = ⟨r, xor(o(a), o(b)⟩ = xor(⟨r, o(a)⟩, ⟨r, o(b)⟩)\n\nFor o(a, b) to be sign symmetric, this scalar product should be zero for all sign symmetry r. This is equivalent to saying that ⟨r, o(a)⟩ and ⟨r, o(b)⟩ are equal for all r in R. In other words, the projection of o(a) and o(b) to R have the same coordinates in the basis. If we order the monomials by grouping them by equal coordinates of projection, we see that the product that are sign symmetric form a block diagonal structure. This means that we can group the monomials by these coordinates.\n\n[L09] Löfberg, Johan. Pre-and post-processing sum-of-squares programs in practice. IEEE transactions on automatic control 54, no. 5 (2009): 1007-1011.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.XORSpace","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.XORSpace","text":"mutable struct XORSpace{T<:Integer}\n    dimension::Int\n    basis::Vector{T}\nend\n\nBasis for a linear subspace of the Hamming space (i.e. set of binary string {0, 1}^n of length n) represented in the bits of an integer of type T. This is used to implement Certificate.Sparsity.SignSymmetry.\n\nConsider the scalar product ⟨a, b⟩ which returns the the xor of the bits of a & b. It is a scalar product since ⟨a, b⟩ = ⟨b, a⟩ and ⟨a, xor(b, c)⟩ = xor(⟨a, b⟩, ⟨a, c⟩).\n\nWe have two options here to compute the orthogonal space.\n\nThe first one is to build an orthogonal basis with some kind of Gram-Schmidt process and then to obtain the orthogonal space by removing the projection from each vector of the basis.\n\nThe second option, which is the one we use here is to compute the row echelon form and then read out the orthogonal subspace directly from it. For instance, if the row echelon form is\n\n1 a 0 c e\n  b 1 d f\n\nthen the orthogonal basis is\n\na 1 b 0 0\nc 0 d 1 0\ne 0 f 0 1\n\nThe basis vector has dimension nonzero elements. Any element added with push! can be obtained as the xor of some of the elements of basis. Moreover, the basis is kept in row echelon form in the sense that the first, second, ..., i - 1th bits of basis[i] are zero and basis[i] is zero if its ith bit is not one.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"Ideal certificates:","category":"page"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"SumOfSquares.Certificate.MaxDegree\nSumOfSquares.Certificate.FixedBasis\nSumOfSquares.Certificate.Newton\nSumOfSquares.Certificate.Remainder\nSumOfSquares.Certificate.Sparsity.Ideal\nSumOfSquares.Certificate.Symmetry.Ideal","category":"page"},{"location":"reference/certificate/#SumOfSquares.Certificate.MaxDegree","page":"Certificate","title":"SumOfSquares.Certificate.MaxDegree","text":"struct MaxDegree{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: SimpleIdealCertificate{CT, BT}\n    cone::CT\n    basis::Type{BT}\n    maxdegree::Int\nend\n\nThe MaxDegree certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by exhibiting a Sum-of-Squares polynomials σ(x) such that p(x) - σ(x) is guaranteed to be zero for all x such that h_i(x) = 0. The polynomial σ(x) is search over cone with a basis of type basis such that the degree of σ(x) does not exceed maxdegree.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.FixedBasis","page":"Certificate","title":"SumOfSquares.Certificate.FixedBasis","text":"struct FixedBasis{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: SimpleIdealCertificate{CT, BT}\n    cone::CT\n    basis::BT\nend\n\nThe FixedBasis certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by exhibiting a Sum-of-Squares polynomials σ(x) such that p(x) - σ(x) is guaranteed to be zero for all x such that h_i(x) = 0. The polynomial σ(x) is search over cone with basis basis.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Newton","page":"Certificate","title":"SumOfSquares.Certificate.Newton","text":"struct Newton{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis, NPT <: Tuple} <: SimpleIdealCertificate{CT, BT}\n    cone::CT\n    basis::Type{BT}\n    variable_groups::NPT\nend\n\nThe Newton certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by exhibiting a Sum-of-Squares polynomials σ(x) such that p(x) - σ(x) is guaranteed to be zero for all x such that h_i(x) = 0. The polynomial σ(x) is search over cone with a basis of type basis chosen using the multipartite Newton polytope with parts variable_groups. If variable_groups = tuple() then it falls back to the classical Newton polytope with all variables in the same part.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Remainder","page":"Certificate","title":"SumOfSquares.Certificate.Remainder","text":"struct Remainder{GCT<:AbstractIdealCertificate} <: AbstractIdealCertificate\n    gram_certificate::GCT\nend\n\nThe Remainder certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by guaranteeing the remainder of p(x) modulo the ideal generated by ⟨h_i⟩ to be nonnegative for all x such that h_i(x) = 0 using the certificate gram_certificate. For instance, if gram_certificate is SumOfSquares.Certificate.Newton, then the certificate Remainder(gram_certificate) will take the remainder before computing the Newton polytope hence might generate a much smaller Newton polytope hence a smaller basis and smaller semidefinite program. However, this then corresponds to a lower degree of the hierarchy which might be insufficient to find a certificate.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.Ideal","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.Ideal","text":"struct Sparsity.Ideal{S <: Sparsity.Pattern, C <: AbstractIdealCertificate} <: SumOfSquares.Certificate.AbstractIdealCertificate\n    sparsity::S\n    certificate::C\nend\n\nSame certificate as certificate except that the Sum-of-Squares polynomial σ is modelled as a sum of Sum-of-Squares polynomials with smaller bases using the sparsity reduction sparsity.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Symmetry.Ideal","page":"Certificate","title":"SumOfSquares.Certificate.Symmetry.Ideal","text":"struct Symmetry.Ideal{C,GT,AT<:SymbolicWedderburn.Action} <: SumOfSquares.Certificate.AbstractIdealCertificate\n    pattern::Symmetry.Pattern{GT,AT}\n    certificate::C\nend\n\nSame certificate as certificate except that the Sum-of-Squares polynomial σ is modelled as a sum of Sum-of-Squares polynomials with smaller bases using the Symbolic Wedderburn decomposition of the symmetry pattern specified by pattern.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"Preorder certificates:","category":"page"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"SumOfSquares.Certificate.Putinar\nSumOfSquares.Certificate.Sparsity.Preorder","category":"page"},{"location":"reference/certificate/#SumOfSquares.Certificate.Putinar","page":"Certificate","title":"SumOfSquares.Certificate.Putinar","text":"struct Putinar{\n    MC<:AbstractIdealCertificate,\n    IC<:AbstractIdealCertificate,\n} <: AbstractPreorderCertificate\n    multipliers_certificate::MC\n    ideal_certificate::IC\n    maxdegree::Int\nend\n\nThe Putinar certificate ensures the nonnegativity of p(x) for all x such that g_i(x) >= 0 and h_i(x) = 0 by exhibiting Sum-of-Squares polynomials σ_i(x) such that p(x) - ∑ σ_i(x) g_i(x) is guaranteed to be nonnegativity for all x such that h_i(x) = 0. The polynomials σ_i(x) are search over cone with a basis of type basis such that the degree of σ_i(x) g_i(x) does not exceed maxdegree.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.Preorder","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.Preorder","text":"struct Sparsity.Preorder{S <: Sparsity.Pattern, C <: SumOfSquares.Certificate.AbstractPreorderCertificate} <: SumOfSquares.Certificate.AbstractPreorderCertificate\n    sparsity::S\n    certificate::C\nend\n\nSame certificate as C except that the Sum-of-Squares polynomials σ_i are modelled as a sum of Sum-of-Squares polynomials with smaller basis using the sparsity reduction sparsity.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"Chordal extension:","category":"page"},{"location":"reference/certificate/","page":"Certificate","title":"Certificate","text":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.neighbors\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.fill_in\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.is_clique\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.LabelledGraph\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_node!\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_edge!\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_clique!\nSumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.completion","category":"page"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.neighbors","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.neighbors","text":"neighbors(G::Graph, node::Int}\n\nReturn neighbors of node in G.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.fill_in","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.fill_in","text":"fill_in(G::Graph{T}, i::T}\n\nReturn number of edges that need to be added to make the neighbors of i a clique.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.is_clique","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.is_clique","text":"is_clique(G::Graph{T}, x::Vector{T})\n\nReturn a Bool indication whether x is a clique in G.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.LabelledGraph","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.LabelledGraph","text":"struct LabelledGraph{T}\n    n2int::Dict{T,Int}\n    int2n::Vector{T}\n    graph::Graph\nend\n\nType to represend a graph with nodes of type T.\n\n\n\n\n\n","category":"type"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_node!","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_node!","text":"add_node!(G::LabelledGraph{T}, i::T) where T\n\nAdd the node i to graph G. If i is already a node of G, only return the reference.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_edge!","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_edge!","text":"add_edge!(G::LabelledGraph{T}, i::T, j::T) where T\n\nAdd the unweighted edge (i, j) to graph G. Duplicate edges are not taken into account.\n\n\n\n\n\nadd_edge!(G::LabelledGraph{T}, e::Tuple{T,T}) where T\n\nAdd the unweighted edge e to graph G. Duplicate edges are not taken into account.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_clique!","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.add_clique!","text":"add_clique!(G::LabelledGraph{T}, x::Vector{T}) where T\n\nAdd all elements of x as nodes to G and add edges such that x is fully connected in G.\n\n\n\n\n\n","category":"function"},{"location":"reference/certificate/#SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.completion","page":"Certificate","title":"SumOfSquares.Certificate.Sparsity.ChordalExtensionGraph.completion","text":"completion(G::Graph, comp::ChordalCompletion)\n\nReturn a chordal extension of G and the corresponding maximal cliques.\n\nThe algoritm is Algorithm 3 in [BA10] with the GreedyFillIn heuristic of Table I.\n\n[BA10] Bodlaender, Hans L., and Arie MCA Koster. Treewidth computations I. Upper bounds. Information and Computation 208, no. 3 (2010): 259-275. Utrecht University, Utrecht, The Netherlands www.cs.uu.nl\n\n\n\n\n\ncompletion(G::Graph, comp::ChordalCompletion)\n\nReturn a cluster completion of G and the corresponding maximal cliques.\n\n\n\n\n\n","category":"function"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"EditURL = \"../../tutorials/Sparsity/term_sparsity.jl\"","category":"page"},{"location":"generated/Sparsity/term_sparsity/#Term-sparsity","page":"Term sparsity","title":"Term sparsity","text":"","category":"section"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"(Image: ) (Image: ) Adapted from: Example 3.5 of [WML20b]","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[WML20a] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. TSSOS: A Moment-SOS hierarchy that exploits term sparsity. arXiv preprint arXiv:1912.08899 (2020).","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[WML20b] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. Chordal-TSSOS: a moment-SOS hierarchy that exploits term sparsity with chordal extension. arXiv preprint arXiv:2003.03210 (2020).","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"using DynamicPolynomials\n@polyvar x[1:3]","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"We would like to find the minimum value of the polynomial","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"poly = x[1]^2 - 2x[1]*x[2] + 3x[2]^2 - 2x[1]^2*x[2] + 2x[1]^2*x[2]^2 - 2x[2]*x[3] + 6x[3]^2 + 18x[2]^2*x[3] - 54x[2]*x[3]^2 + 142x[2]^2*x[3]^2","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"The minimum value of the polynomial can be found to be zero.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"import CSDP\nsolver = CSDP.Optimizer\nusing SumOfSquares\nfunction sos_min(sparsity)\n    model = Model(solver)\n    @variable(model, t)\n    @objective(model, Max, t)\n    con_ref = @constraint(model, poly - t in SOSCone(), sparsity = sparsity)\n    optimize!(model)\n    return value(t), moment_matrix(con_ref)\nend\n\nbound, ν = sos_min(Sparsity.NoPattern())\nbound","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"We find the corresponding minimizer (0, 0, 0) by matching the moments of the moment matrix with a dirac measure centered at this minimizer.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"atomic_measure(ν, 1e-6)","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"We can see below that the basis contained 6 monomials hence we needed to use 6x6 PSD matrix variables.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"ν.basis","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"Using the monomial/term sparsity method of [WML20a] based on cluster completion, we find the same bound.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"bound, ν = sos_min(Sparsity.Monomial())\nbound","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"Which is not suprising as no sparsity reduction could be performed.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[sub.basis for sub in ν.blocks]","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"Using the monomial/term sparsity method of [WML20b] based on chordal completion, the lower bound is smaller than 0.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"bound, ν = sos_min(Sparsity.Monomial(ChordalCompletion()))\nbound","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"However, this bound was obtained with an SDP with 4 matrices of size 3x3.","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[sub.basis for sub in ν.blocks]","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"","category":"page"},{"location":"generated/Sparsity/term_sparsity/","page":"Term sparsity","title":"Term sparsity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Noncommutative and Hermitian/sums_of_hermitian_squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"EditURL = \"../../tutorials/Noncommutative and Hermitian/sums_of_hermitian_squares.jl\"","category":"page"},{"location":"generated/Noncommutative and Hermitian/sums_of_hermitian_squares/#Sums-of-Hermitian-squares","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"","category":"section"},{"location":"generated/Noncommutative and Hermitian/sums_of_hermitian_squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Noncommutative and Hermitian/sums_of_hermitian_squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"using SumOfSquares\n\nusing DynamicPolynomials\n@ncpolyvar x y\np = (x + im * y) * (x - im * y)\n\nimport CSDP\nmodel = Model(CSDP.Optimizer)\ncone = NonnegPolyInnerCone{MOI.HermitianPositiveSemidefiniteConeTriangle}()\ncon_ref = @constraint(model, p in cone)\noptimize!(model)\nsos_decomposition(con_ref, 1e-6)","category":"page"},{"location":"generated/Noncommutative and Hermitian/sums_of_hermitian_squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"","category":"page"},{"location":"generated/Noncommutative and Hermitian/sums_of_hermitian_squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"EditURL = \"../../tutorials/Getting started/dualization.jl\"","category":"page"},{"location":"generated/Getting started/dualization/#On-the-importance-of-Dualization","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"using DynamicPolynomials\nusing SumOfSquares","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"Sum-of-Squares programs are usually solved by SemiDefinite Programming solvers (SDPs). These programs can be represented into two different formats: Either the standard conic form, also known as kernel form:","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"beginaligned\n  minlimits_Q in mathbbS_n  langle C Q rangle\n  textsubject to  langle A_i Q rangle = b_i quad i=12ldotsm\n                       Q succeq 0\nendaligned","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"or the geometric conic form, also known as image form:","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"beginaligned\n  maxlimits_y in mathbbR^m  langle b y rangle\n  textsubject to  C succeq sum_i=1^m A_i y_i\n                      y mathsffree\nendaligned","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"In this tutorial, we investigate in which of these two forms a Sum-of-Squares constraint should be written into. Consider the simple example of trying to determine whether the following univariate polynomial is a Sum-of-Squares:","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"import SCS\n@polyvar x\np = (x + 1)^2 * (x + 2)^2\nmodel_scs = Model(SCS.Optimizer)\ncon_ref = @constraint(model_scs, p in SOSCone())\noptimize!(model_scs)","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"As we can see in the log, SCS reports 6 variables and 11 constraints. We can also choose to dualize the problem before it is passed to SCS as follows:","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"using Dualization\nmodel_dual_scs = Model(dual_optimizer(SCS.Optimizer))\n@objective(model_dual_scs, Max, 0.0)\ncon_ref = @constraint(model_dual_scs, p in SOSCone())\noptimize!(model_dual_scs)","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"This time, SCS reports 5 variables and 6 constraints.","category":"page"},{"location":"generated/Getting started/dualization/#Bridges-operating-behind-the-scenes","page":"On the importance of Dualization","title":"Bridges operating behind the scenes","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"The difference comes from the fact that, when designing the JuMP interface of SCS, it was decided that the model would be read in the image form. SCS therefore declares that it only supports free variables, represented in JuMP as variables in MOI.Reals and affine semidefinite constraints, represented in JuMP as MOI.VectorAffineFunction-in-MOI.PositiveSemidefiniteConeTriangle constraints. On the other hand, SumOfSquares gave the model in kernel form so the positive semidefinite (PSD) variables were reformulated as free variables constrained to be PSD using an affine PSD constraints.","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"This transformation is done transparently without warning but it can be inspected using print_active_bridges. As shown below, we can see Unsupported variable: MOI.PositiveSemidefiniteConeTriangle and adding as constraint indicating that PSD variables are not supported and they are added as free variables. Then we have Unsupported constraint: MOI.VectorOfVariables-in-MOI.PositiveSemidefiniteConeTriangle indicating that SCS does not support constraining variables in the PSD cone so it will just convert it into affine expressions in the PSD cone. Of course, this is equivalent but it means that SCS will not exploit this particular structure of the problem hence solving might be less efficient.","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"print_active_bridges(model_scs)","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"With the dual version, we can see that variables in the PSD cone are supported directly hence we don't need that extra conversion.","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"print_active_bridges(model_dual_scs)","category":"page"},{"location":"generated/Getting started/dualization/#In-more-details","page":"On the importance of Dualization","title":"In more details","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"Consider a polynomial","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"p(x) = sum_alpha p_alpha x^alpha","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"a vector of monomials b(x) and the set","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"mathcalA_alpha = (beta gamma) in b(x)^2 mid x^beta x^gamma = x^alpha","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"The constraint encoding the existence of a PSD matrix Q such that p(x) = b(x)' * Q * b(x) can be written in standard conic form as follows:","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"beginaligned\n  langle sum_(beta gamma) in mathcalA_alpha e_beta e_gamma^top Q rangle  = p_alpha quadforall alpha\n  Q  succeq 0\nendaligned","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"Given an arbitrary choice of elements in each set mathcalA_alpha: (beta_alpha gamma_alpha) in mathcalA_alpha. It can also equivalently be written in the geometric conic form as follows:","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"beginaligned\n  p_alpha e_beta_alpha e_gamma_alpha^top +\n  sum_(beta gamma) in mathcalA_alpha setminus (beta_alpha gamma_alpha)\n  y_betagamma (e_beta e_gamma - e_beta_alpha e_gamma_alpha^top)^top\n   succeq 0\n  y_betagamma  text free\nendaligned","category":"page"},{"location":"generated/Getting started/dualization/#Should-I-dualize-or-not-?","page":"On the importance of Dualization","title":"Should I dualize or not ?","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"Let's study the evolution of the dimensions m and n of the semidefinite program in two extreme examples and then try to extrapolate from these.","category":"page"},{"location":"generated/Getting started/dualization/#Univariate-case","page":"On the importance of Dualization","title":"Univariate case","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"Suppose p is a univariate polynomial of degree 2d. Then n will be equal to d(d + 1)/2 for both the standard and geometric conic forms. On the other hand, m will be equal to 2d + 1 for the standard conic form and d(d + 1) / 2 - (2d + 1) for the geometric form case. So m grows linearly for the kernel form but quadratically for the image form!","category":"page"},{"location":"generated/Getting started/dualization/#Quadratic-case","page":"On the importance of Dualization","title":"Quadratic case","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"Suppose p is a quadratic form of d variables. Then n will be equal to d for both the standard and geometric conic forms. On the other hand, m will be equal to d(d + 1)/2 for the standard conic form and 0 for the geometric form case. So m grows quadratically for the kernel form but is zero for the image form!","category":"page"},{"location":"generated/Getting started/dualization/#In-general","page":"On the importance of Dualization","title":"In general","text":"","category":"section"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"In general, if s_d is the dimension of the space of polynomials of degree d then m = s_2d for the kernel form and m = s_d(s_d + 1)2 - s_2d for the image form. As a rule of thumb, the kernel form will have a smaller m if p has a low number of variables and low degree and vice versa. Of course, you can always try with and without Dualization and see which one works best.","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"","category":"page"},{"location":"generated/Getting started/dualization/","page":"On the importance of Dualization","title":"On the importance of Dualization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"EditURL = \"../../tutorials/Sparsity/sign_symmetry.jl\"","category":"page"},{"location":"generated/Sparsity/sign_symmetry/#Sign-symmetry","page":"Sign symmetry","title":"Sign symmetry","text":"","category":"section"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"(Image: ) (Image: ) Adapted from: Example 4 of [L09]","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"[L09] Lofberg, Johan. Pre-and post-processing sum-of-squares programs in practice. IEEE transactions on automatic control 54, no. 5 (2009): 1007-1011.","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"using DynamicPolynomials\n@polyvar x[1:3]","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"We would like to determine whether the following polynomial is a sum-of-squares.","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"poly = 1 + x[1]^4 + x[1] * x[2] + x[2]^4 + x[3]^2","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"In order to do this, we can solve the following Sum-of-Squares program.","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"import CSDP\nsolver = CSDP.Optimizer\nusing SumOfSquares\nfunction sos_check(sparsity)\n    model = Model(solver)\n    con_ref = @constraint(model, poly in SOSCone(), sparsity = sparsity)\n    optimize!(model)\n    println(solution_summary(model))\n    return gram_matrix(con_ref)\nend\n\ng = sos_check(Sparsity.NoPattern())\ng.basis.monomials","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"As detailed in the Example 4 of [L09], we can exploit the sign symmetry of the polynomial to decompose the large positive semidefinite matrix into smaller ones.","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"g = sos_check(Sparsity.SignSymmetry())\nmonos = [sub.basis.monomials for sub in g.blocks]","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"","category":"page"},{"location":"generated/Sparsity/sign_symmetry/","page":"Sign symmetry","title":"Sign symmetry","text":"This page was generated using Literate.jl.","category":"page"},{"location":"variables/#Polynomial-and-Sum-of-Squares-variables","page":"Variables","title":"Polynomial and Sum-of-Squares variables","text":"","category":"section"},{"location":"variables/#Polynomial-variables","page":"Variables","title":"Polynomial variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"While JuMP allows to create decision variables representing a number whose value needs to be optimized upon by the optimizer, PolyJuMP allows to create polynomial decision variables. In order to do that, we first need to create polynomial variables with the @polyvar macro:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> using DynamicPolynomials # or TypedPolynomials, pick your favorite\n\njulia> @polyvar x y\n(x, y)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Note that these should not be confused with JuMP's decision variables which are created using the @variable macro. The polynomial decision variable that will be created need to be parametrized by a polynomial basis of finite size. For instance, if we want to find a quadratic polynomial, we can parametrize it with all monomials of degree between 0 and 2. Generating a vector with such monomials can be achieved through the monomials function:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> X = monomials([x, y], 0:2)\n6-element MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}:\n 1\n y\n x\n y²\n xy\n x²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can now create our polynomial variable p as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> using SumOfSquares\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, p, Poly(X))\n(_[1]) + (_[2])y + (_[3])x + (_[4])y² + (_[5])xy + (_[6])x²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"This creates a vector of decision variables a and sets p as the scalar product between a and X.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Just like with classical JuMP's decision variables, containers of polynomial variables can be created as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, [1:3, 1:4], Poly(X))       # Creates a Matrix\n3×4 Matrix{Polynomial{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}, VariableRef}}:\n (_[7]) + (_[8])y + (_[9])x + (_[10])y² + (_[11])xy + (_[12])x²     …  (_[61]) + (_[62])y + (_[63])x + (_[64])y² + (_[65])xy + (_[66])x²\n (_[13]) + (_[14])y + (_[15])x + (_[16])y² + (_[17])xy + (_[18])x²     (_[67]) + (_[68])y + (_[69])x + (_[70])y² + (_[71])xy + (_[72])x²\n (_[19]) + (_[20])y + (_[21])x + (_[22])y² + (_[23])xy + (_[24])x²     (_[73]) + (_[74])y + (_[75])x + (_[76])y² + (_[77])xy + (_[78])x²\n\njulia> @variable(model, [[:a, :b], -2:2], Poly(X)) # Creates a DenseAxisArray\n2-dimensional DenseAxisArray{DynamicPolynomials.Polynomial{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, MultivariatePolynomials.Graded{MultivariatePolynomials.LexOrder}, VariableRef},2,...} with index sets:\n    Dimension 1, [:a, :b]\n    Dimension 2, -2:2\nAnd data, a 2×5 Matrix{DynamicPolynomials.Polynomial{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, MultivariatePolynomials.Graded{MultivariatePolynomials.LexOrder}, VariableRef}}:\n (_[79]) + (_[80])y + (_[81])x + (_[82])y² + (_[83])xy + (_[84])x²  …  (_[127]) + (_[128])y + (_[129])x + (_[130])y² + (_[131])xy + (_[132])x²\n (_[85]) + (_[86])y + (_[87])x + (_[88])y² + (_[89])xy + (_[90])x²     (_[133]) + (_[134])y + (_[135])x + (_[136])y² + (_[137])xy + (_[138])x²\n\njulia> @variable(model, [i=1:3, j=i:3], Poly(X))   # Creates a SparseAxisArray\nJuMP.Containers.SparseAxisArray{Polynomial{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}, VariableRef}, 2, Tuple{Int64, Int64}} with 6 entries:\n  [1, 1]  =  (_[139]) + (_[140])*y + (_[141])*x + (_[142])*y^2 + (_[143])*x*y + (_[144])*x^2\n  [1, 2]  =  (_[145]) + (_[146])*y + (_[147])*x + (_[148])*y^2 + (_[149])*x*y + (_[150])*x^2\n  [1, 3]  =  (_[151]) + (_[152])*y + (_[153])*x + (_[154])*y^2 + (_[155])*x*y + (_[156])*x^2\n  [2, 2]  =  (_[157]) + (_[158])*y + (_[159])*x + (_[160])*y^2 + (_[161])*x*y + (_[162])*x^2\n  [2, 3]  =  (_[163]) + (_[164])*y + (_[165])*x + (_[166])*y^2 + (_[167])*x*y + (_[168])*x^2\n  [3, 3]  =  (_[169]) + (_[170])*y + (_[171])*x + (_[172])*y^2 + (_[173])*x*y + (_[174])*x^2","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For more flexibility, polynomials parametrized by decision variables can also be created \"by hand\" for instance as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, α)\nα\n\njulia> @variable(model, β)\nβ\n\njulia> p = α*x^2 + (α+β)*y^2*x + β*y^3\n(α)x² + (β)y³ + (α + β)xy²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"The coefficients of the polynomial can even be quadratic, e.g.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> p = (3α^2+β)*x^2 + (α*β+2β)*y^2*x + β*y^3\n(3 α² + β)x² + (β)y³ + (α*β + 2 β)xy²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Let me stress again the distinction between α and β which are decision variables and x and y which are polynomial variables.","category":"page"},{"location":"variables/#Nonnegative-polynomial-variables","page":"Variables","title":"Nonnegative polynomial variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In order to create a sum-of-squares polynomial variable, the syntax is exactly the same except SOSPoly should be used instead of Poly. For instance, the following code creates a 3 times 4 matrix of sum-of-squares polynomial variables:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, [1:2], SOSPoly(X))\n2-element Vector{GramMatrix{VariableRef, MonomialBasis{Monomial{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}, MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}}, AffExpr, SymMatrix{VariableRef}}}:\n GramMatrix with row/column basis:\n MonomialBasis([1, y, x, y^2, x*y, x^2])\nAnd entries in a 6×6 SymMatrix{VariableRef}:\n _[177]  _[178]  _[180]  _[183]  _[187]  _[192]\n _[178]  _[179]  _[181]  _[184]  _[188]  _[193]\n _[180]  _[181]  _[182]  _[185]  _[189]  _[194]\n _[183]  _[184]  _[185]  _[186]  _[190]  _[195]\n _[187]  _[188]  _[189]  _[190]  _[191]  _[196]\n _[192]  _[193]  _[194]  _[195]  _[196]  _[197]\n GramMatrix with row/column basis:\n MonomialBasis([1, y, x, y^2, x*y, x^2])\nAnd entries in a 6×6 SymMatrix{VariableRef}:\n _[198]  _[199]  _[201]  _[204]  _[208]  _[213]\n _[199]  _[200]  _[202]  _[205]  _[209]  _[214]\n _[201]  _[202]  _[203]  _[206]  _[210]  _[215]\n _[204]  _[205]  _[206]  _[207]  _[211]  _[216]\n _[208]  _[209]  _[210]  _[211]  _[212]  _[217]\n _[213]  _[214]  _[215]  _[216]  _[217]  _[218]","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"There is however an important difference between the meaning of the vector of monomials X between Poly and SOSPoly. For SOSPoly, it creates a positive semidefinite matrix of variables Q and sets p as the value of X' * Q * X. That is, for instance, if X contains all the monomials of degree 2, then all the monomials of p will have degree 4 (i.e. p will be a quartic form).","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Similarly, to create diagonally-dominant-sum-of-squares polynomial variables (see (Ahmadi and Majumdar, 2017; Definition 3.1)), use DSOSPoly(X). This creates a diagonally dominant matrix of variables Q and sets the polynomial variables as the value of X' * Q * X.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Finally, to create scaled-diagonally-dominant-sum-of-squares polynomial variables (see (Ahmadi and Majumdar, 2017; Definition 3.2)), use SDSOSPoly(X). This creates a scaled diagonally dominant matrix of variables Q and sets the polynomial variables as the value of X' * Q * X.","category":"page"},{"location":"variables/#Choosing-a-polynomial-basis","page":"Variables","title":"Choosing a polynomial basis","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In the previous section, we show how to create polynomial variables from a monomial basis. However, the monomial basis is only a particular case of polynomial basis and while using a different basis of the same space of polynomial is would give an equivalent program, it might be more stable numerically (see (Blekherman et al., 2012; Section 3.1.5)).","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For instance, creating an univariate cubic polynomial variable p using the Chebyshev basis can be done as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> cheby_basis = FixedPolynomialBasis([1, x, 2x^2-1, 4x^3-3x])\nFixedPolynomialBasis([1, x, -1 + 2x², -3x + 4x³])\n\njulia> @variable(model, variable_type=Poly(cheby_basis))\n(_[219] - _[221]) + (_[220] - 3 _[222])x + (2 _[221])x² + (4 _[222])x³","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"and to create a quadratic form variable q using the scaled monomial basis (see (Blekherman et al., 2012; Section 3.1.5)), use the following:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> X = monomials([x, y], 2)\n3-element MonomialVector{DynamicPolynomials.Commutative{DynamicPolynomials.CreationOrder}, Graded{LexOrder}}:\n y²\n xy\n x²\n\njulia> scaled_basis = ScaledMonomialBasis(X)\nScaledMonomialBasis([y², xy, x²])\n\njulia> @variable(model, variable_type=Poly(scaled_basis))\n(_[223])y² + (1.4142135623730951 _[224])xy + (_[225])x²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"which is equivalent to","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> scaled_basis = FixedPolynomialBasis([x^2, √2*x*y, y^2])\nFixedPolynomialBasis([x², 1.4142135623730951xy, y²])\n\njulia> @variable(model, variable_type=Poly(scaled_basis))\n(_[228])y² + (1.4142135623730951 _[227])xy + (_[226])x²","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"EditURL = \"../../tutorials/Getting started/circle.jl\"","category":"page"},{"location":"generated/Getting started/circle/#Nonnegative-over-a-variety","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"","category":"section"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"The polynomial 1 - y^2 is nonnegative for all y in the unit circle. This can be verified using Sum-of-Squares.","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"using DynamicPolynomials\nusing SumOfSquares\n@polyvar x y\nS = @set x^2 + y^2 == 1","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"We need to pick an SDP solver, see here for a list of the available choices. The domain over which the nonnegativity of 1 - y^2 should be certified is specified through the domain keyword argument.","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"import CSDP\nmodel = SOSModel(CSDP.Optimizer)\nset_silent(model)\ncon_ref = @constraint(model, 1 - y^2 >= 0, domain = S)\noptimize!(model)","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"We can see that the model was feasible:","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"solution_summary(model)","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"The certificate can be obtained as follows:","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"sos_decomposition(con_ref, 1e-6)","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"It returns x^2 which is a valid certificate as: $ 1 - y^2 \\equiv x^2 \\pmod{x^2 + y^2 - 1} $","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"","category":"page"},{"location":"generated/Getting started/circle/","page":"Nonnegative over a variety","title":"Nonnegative over a variety","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"EditURL = \"../../tutorials/Systems and Control/barrier_certificate.jl\"","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/#Barrier-certificates-for-collision-avoidance","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"","category":"section"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Adapted from: Example 2 of \"Engineering applications of SOS polynomials\" by Georgina Hall, from the 2019 AMS Short Course on Sum of Squares: Theory and Applications Implementation by: Hugo Tadashi Kussaba","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"using DynamicPolynomials\n@polyvar x[1:2]\n\nusing SumOfSquares\nusing CSDP","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"solver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver);\nnothing #hide","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"We define below the vector field textdxtextdt = f","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"f = [ x[2],\n     -x[1] + (1/3)*x[1]^3 - x[2]]","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Semi-algebraic function describing the unsafe set 𝒳ᵤ","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"g₁ = -(x[1]+1)^2 - (x[2]+1)^2 + 0.16  # 𝒳ᵤ = {x ∈ R²: g₁(x) ≥ 0}","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Semi-algebraic function describing the initial set 𝒳₀","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"h₁ = -(x[1]-1.5)^2 - x[2]^2 + 0.25    # 𝒳₀ = {x ∈ R²: h₁(x) ≥ 0}","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Define SOS barrier function B","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"monos = monomials(x, 0:4)\n@variable(model, B, Poly(monos))","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Define barrier certificate constraints using SOS relaxation","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"B(x) > 0 for all x ∈ 𝒳ᵤ","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"ε = 0.001\n@constraint(model, B >= ε, domain = @set(g₁ >= 0))","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"B(x) ≤ 0 for all x ∈ 𝒳₀","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"@constraint(model, B <= 0, domain = @set(h₁ >= 0))","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Ḃ(x) ≤ 0 for all x ∈ R²","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"using LinearAlgebra # Needed for `dot`\ndBdt = dot(differentiate(B, x), f)\n@constraint(model, -dBdt >= 0)","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"The model is ready to be optimized by the solver:","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"JuMP.optimize!(model)","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"We verify that the solver has found a feasible solution:","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"JuMP.primal_status(model)","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"Plot the phase plot with the 0-level set of the barrier function, and the boundary of the initial and unsafe sets","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"import DifferentialEquations, Plots, ImplicitPlots\nfunction phase_plot(f, B, g₁, h₁, quiver_scaling, Δt, X0, solver = DifferentialEquations.Tsit5())\n    X₀plot = ImplicitPlots.implicit_plot(h₁; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"X₀\", linecolor=:blue)\n    Xᵤplot = ImplicitPlots.implicit_plot!(g₁; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"Xᵤ\", linecolor=:teal)\n    Bplot  = ImplicitPlots.implicit_plot!(B; xlims=(-2, 3), ylims=(-2.5, 2.5), resolution = 1000, label=\"B = 0\", linecolor=:red)\n    Plots.plot(X₀plot)\n    Plots.plot!(Xᵤplot)\n    Plots.plot!(Bplot)\n    ∇(vx, vy) = [fi(x[1] => vx, x[2] => vy) for fi in f]\n    ∇pt(v, p, t) = ∇(v[1], v[2])\n    function traj(v0)\n        tspan = (0.0, Δt)\n        prob = DifferentialEquations.ODEProblem(∇pt, v0, tspan)\n        return DifferentialEquations.solve(prob, solver, reltol=1e-8, abstol=1e-8)\n    end\n    ticks = -5:0.5:5\n    X = repeat(ticks, 1, length(ticks))\n    Y = X'\n    Plots.quiver!(X, Y, quiver = (x, y) -> ∇(x, y) / quiver_scaling, linewidth=0.5)\n    for x0 in X0\n        Plots.plot!(traj(x0), vars=(1, 2), label = nothing)\n    end\n    Plots.plot!(xlims = (-2, 3), ylims = (-2.5, 2.5))\nend\n\nphase_plot(f, value(B), g₁, h₁, 10, 30.0, [[x1, x2] for x1 in 1.2:0.2:1.7, x2 in -0.35:0.1:0.35])","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"","category":"page"},{"location":"generated/Systems and Control/barrier_certificate/","page":"Barrier certificates for collision avoidance","title":"Barrier certificates for collision avoidance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"EditURL = \"../../tutorials/Systems and Control/lyapunov_function_search.jl\"","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/#Lyapunov-Function-Search","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"","category":"section"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO2 (See Section 4.2 of SOSTOOLS User's Manual)","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"using DynamicPolynomials\n@polyvar x[1:3]","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We define below the vector field textdxtextdt = f","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"f = [-x[1]^3 - x[1] * x[3]^2,\n     -x[2] - x[1]^2 * x[2],\n     -x[3] - 3x[3] / (x[3]^2 + 1) + 3x[1]^2 * x[3]]","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"using SumOfSquares\nusing CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver);\nnothing #hide","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We are searching for a Lyapunov function V(x) with monomials x_1^2, x_2^2 and x_3^2. We first define the monomials to be used for the Lyapunov function:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"monos = x.^2","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We now define the Lyapunov function as a polynomial decision variable with these monomials:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"@variable(model, V, Poly(monos))","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We need to make sure that the Lyapunov function is strictly positive. We can do this with a constraint V(x) ge epsilon (x_1^2 + x_2^2 + x_3^2), let's pick epsilon = 1:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"@constraint(model, V >= sum(x.^2))","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We now compute textdVtextdx cdot f.","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"using LinearAlgebra # Needed for `dot`\ndVdt = dot(differentiate(V, x), f)","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"The denominator is x3^2 + 1 is strictly positive so the sign of dVdt is the same as the sign of its numerator.","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"P = dVdt.num","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"Hence, we constrain this numerator to be nonnegative:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"@constraint(model, P <= 0)","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"The model is ready to be optimized by the solver:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"JuMP.optimize!(model)","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We verify that the solver has found a feasible solution:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"JuMP.primal_status(model)","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We can now obtain this feasible solution with:","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"value(V)","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"","category":"page"},{"location":"generated/Systems and Control/lyapunov_function_search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/standard_form/#Standard-form","page":"Standard form","title":"Standard form","text":"","category":"section"},{"location":"reference/standard_form/#JuMP-variables","page":"Standard form","title":"JuMP variables","text":"","category":"section"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.PolyJuMP.Poly","category":"page"},{"location":"reference/standard_form/#PolyJuMP.Poly","page":"Standard form","title":"PolyJuMP.Poly","text":"struct Poly{PB<:AbstractPolynomialBasis} <: AbstractPoly\n    polynomial_basis::PB\nend\n\nPolynomial variable v^top p where v is a vector of new decision variables and p is a vector of polynomials for the basis polynomial_basis.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#JuMP-Sets","page":"Standard form","title":"JuMP Sets","text":"","category":"section"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Approximations of the cone of nonnegative polynomials:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.NonnegPolyInnerCone\nSumOfSquares.SOSCone\nSumOfSquares.SDSOSCone\nSumOfSquares.DSOSCone","category":"page"},{"location":"reference/standard_form/#SumOfSquares.NonnegPolyInnerCone","page":"Standard form","title":"SumOfSquares.NonnegPolyInnerCone","text":"struct NonnegPolyInnerCone{MCT <: MOI.AbstractVectorSet}\nend\n\nInner approximation of the cone of nonnegative polynomials defined by the set of polynomials of the form\n\nX^\\top Q X\n\nwhere X is a vector of monomials and Q is a symmetric matrix that belongs to the cone psd_inner.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.SOSCone","page":"Standard form","title":"SumOfSquares.SOSCone","text":"const SOSCone = NonnegPolyInnerCone{MOI.PositiveSemidefiniteConeTriangle}\n\nSum-of-squares cone; see NonnegPolyInnerCone.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.SDSOSCone","page":"Standard form","title":"SumOfSquares.SDSOSCone","text":"const SDSOSCone = NonnegPolyInnerCone{ScaledDiagonallyDominantConeTriangle}\n\nScaled-diagonally-dominant-sum-of-squares cone; see (Ahmadi and Majumdar, 2017; Definition 2) and NonnegPolyInnerCone.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.DSOSCone","page":"Standard form","title":"SumOfSquares.DSOSCone","text":"const DSOSCone = NonnegPolyInnerCone{DiagonallyDominantConeTriangle}\n\nDiagonally-dominant-sum-of-squares cone; see (Ahmadi and Majumdar, 2017; Definition 2) and NonnegPolyInnerCone.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Approximations of the cone of positive semidefinite polynomial matrices:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.PSDMatrixInnerCone\nSumOfSquares.SOSMatrixCone","category":"page"},{"location":"reference/standard_form/#SumOfSquares.PSDMatrixInnerCone","page":"Standard form","title":"SumOfSquares.PSDMatrixInnerCone","text":"struct PSDMatrixInnerCone{MCT <: MOI.AbstractVectorSet} <: PolyJuMP.PolynomialSet\nend\n\nInner approximation of the cone of polynomial matrices P(x) that are positive semidefinite for any x defined by the set of n times n polynomial matrices such that the polynomial y^top P(x) y belongs to NonnegPolyInnerCone{MCT} where y is a vector of n auxiliary polynomial variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.SOSMatrixCone","page":"Standard form","title":"SumOfSquares.SOSMatrixCone","text":"const SOSMatrixCone = PSDMatrixInnerCone{MOI.PositiveSemidefiniteConeTriangle}\n\nSum-of-squares matrices cone; see (Blekherman et al., 2012; Section 3.3.2) and PSDMatrixInnerCone.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Approximations of the cone of convex polynomials:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.ConvexPolyInnerCone\nSumOfSquares.SOSConvexCone","category":"page"},{"location":"reference/standard_form/#SumOfSquares.ConvexPolyInnerCone","page":"Standard form","title":"SumOfSquares.ConvexPolyInnerCone","text":"struct ConvexPolyInnerCone{MCT} <: PolyJuMP.PolynomialSet end\n\nInner approximation of the set of convex polynomials defined by the set of polynomials such that their hessian belongs to to the set PSDMatrixInnerCone{MCT}()\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.SOSConvexCone","page":"Standard form","title":"SumOfSquares.SOSConvexCone","text":"const SOSConvexCone = ConvexPolyInnerCone{MOI.PositiveSemidefiniteConeTriangle}\n\nSum-of-squares convex polynomials cone; see (Blekherman et al., 2012; Section 3.3.3) and ConvexPolyInnerCone.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Approximations of the cone of copositive matrices:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.CopositiveInner","category":"page"},{"location":"reference/standard_form/#SumOfSquares.CopositiveInner","page":"Standard form","title":"SumOfSquares.CopositiveInner","text":"struct CopositiveInner{S} <: PolyJuMP.PolynomialSet\n    # Inner approximation of the PSD cone, i.e. typically either\n    # `SOSCone`, `DSOSCone` or `SDSOSCone`,\n    psd_inner::S\nend\n\nA symmetric matrix Q is copositive if x^top Q x ge 0 for all vector x in the nonnegative orthant. Checking copositivity is a co-NP-complete problem (Murty and Kabadi, 1987) and this cone is only the inner approximation of the cone of copositive symmetric matrices given by Minknowski sum of psd_inner and the cone of symmetric matrices with nonnegative entries (the diagonal entries can be chosen to be zero) (Blekherman et al., 2012; Lemma 3.164).\n\nThe matrix with nonnegative entries can be interpreted as lagrangian multipliers. For instance,\n\n@polyvar x y\n@constraint(model, x^2 - 2x*y + y^2 in CopositiveInner(SOSCone()))\n\nis equivalent to\n\n# Matrix that we require to be copositive\nQ = [ 1 -1\n     -1  1]\nλ = @variable(model, lower_bound=0)\n# Symmetric matrix of nonnegative entries\nΛ = [0 λ\n     λ 0]\nusing LinearAlgebra # For `Symmetric`\n@constraint(model, Symmetric(Q - Λ) in PSDCone())\n\nwhich is equivalent to\n\n@polyvar x y\nλ = @variable(model, lower_bound=0)\n@constraint(model, x^2 - 2x*y + y^2 - 2*λ * x*y in SOSCone())\n\nwhich is the same as, using the domain keyword,\n\n@polyvar x y\n@constraint(model, x^2 - 2x*y + y^2 in SOSCone(), domain = @set x*y ≥ 0)\n\nAs an important difference with its equivalent forms, the GramMatrixAttribute for the copositive constraint is given by matrix Q while for the equivalent form using the domain keyword, the value of the attribute would correspond to the the gram matrix in the psd_inner cone, i.e. which should be equal to Q - Λ.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SAGE cones:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.PolyJuMP.SAGE.Polynomials\nSumOfSquares.PolyJuMP.SAGE.Signomials\nSumOfSquares.PolyJuMP.SAGE.SignomialsBridge\nSumOfSquares.PolyJuMP.SAGE.AGEBridge","category":"page"},{"location":"reference/standard_form/#PolyJuMP.SAGE.Polynomials","page":"Standard form","title":"PolyJuMP.SAGE.Polynomials","text":"struct Polynomials{M<:Union{Nothing,Int,MP.AbstractMonomial}} <: PolyJuMP.PolynomialSet\n\nSums of AM/GM Exponential for polynomials.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#PolyJuMP.SAGE.Signomials","page":"Standard form","title":"PolyJuMP.SAGE.Signomials","text":"struct Signomials{M<:Union{Nothing,Int,MP.AbstractMonomial}} <: PolyJuMP.PolynomialSet\n\nSums of AM/GM Exponential for signomials.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#PolyJuMP.SAGE.SignomialsBridge","page":"Standard form","title":"PolyJuMP.SAGE.SignomialsBridge","text":"SignomialsBridge{T,S,P,F} <: MOI.Bridges.Constraint.AbstractBridge\n\nWe use the Signomials Representative SR equation of [MCW21].\n\n[MCW20] Riley Murray, Venkat Chandrasekaran, Adam Wierman \"Newton Polytopes and Relative Entropy Optimization\" https://arxiv.org/abs/1810.01614 [MCW21] Murray, Riley, Venkat Chandrasekaran, and Adam Wierman. \"Signomials and polynomial optimization via relative entropy and partial dualization.\" Mathematical Programming Computation 13 (2021): 257-295. https://arxiv.org/pdf/1907.00814.pdf\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#PolyJuMP.SAGE.AGEBridge","page":"Standard form","title":"PolyJuMP.SAGE.AGEBridge","text":"AGEBridge{T,F,G,H} <: MOI.Bridges.Constraint.AbstractBridge\n\nThe nonnegativity of x ≥ 0 in\n\n∑ ci x^αi ≥ -c0 x^α0\n\ncan be reformulated as\n\n∑ ci exp(αi'y) ≥ -β exp(α0'y)\n\nIn any case, it is shown to be equivalent to\n\n∃ ν ≥ 0 s.t. D(ν, exp(1)*c) ≤ β, ∑ νi αi = α0 ∑ νi [CP16, (3)]\n\nwhere N(ν, λ) = ∑ νj log(νj/λj) is the relative entropy function. The constant exp(1) can also be moved out of D into\n\n∃ ν ≥ 0 s.t. D(ν, c) - ∑ νi ≤ β, ∑ νi αi = α0 ∑ νi [MCW21, (2)]\n\nThe relative entropy cone in MOI is (u, v, w) such that D(w, v) ≥ u. Therefore, we can either encode (β, exp(1)*c, ν) [CP16, (3)] or (β + ∑ νi, c, ν) [MCW21, (2)]. In this bridge, we use the second formulation.\n\nnote: Note\nA direct application of the Arithmetic-Geometric mean inequality gives∃ ν ≥ 0 s.t. D(ν, exp(1)*c) ≤ -log(-β), ∑ νi αi = α0, ∑ νi = 1 [CP16, (4)]which is not jointly convex in (ν, c, β). The key to get the convex formulation [CP16, (3)] or [MCW21, (2)] instead is to use the convex conjugacy between the exponential and the negative entropy functions [CP16, (iv)].\n\n[CP16] Chandrasekaran, Venkat, and Parikshit Shah. \"Relative entropy relaxations for signomial optimization.\" SIAM Journal on Optimization 26.2 (2016): 1147-1173. [MCW21] Murray, Riley, Venkat Chandrasekaran, and Adam Wierman. \"Signomials and polynomial optimization via relative entropy and partial dualization.\" Mathematical Programming Computation 13 (2021): 257-295. https://arxiv.org/pdf/1907.00814.pdf\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#MOI-Sets","page":"Standard form","title":"MOI Sets","text":"","category":"section"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Sum-of-Squares cones:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.SOSPolynomialSet\nSumOfSquares.WeightedSOSCone","category":"page"},{"location":"reference/standard_form/#SumOfSquares.SOSPolynomialSet","page":"Standard form","title":"SumOfSquares.SOSPolynomialSet","text":"struct SOSPolynomialSet{\n    DT<:AbstractSemialgebraicSet,\n    MT<:MP.AbstractMonomial,\n    MVT<:AbstractVector{MT},\n    CT<:Certificate.AbstractCertificate,\n} <: MOI.AbstractVectorSet\n    domain::DT\n    monomials::MVT\n    certificate::CT\nend\n\nThe sum-of-squares cone is the set of vectors of coefficients a for monomials monomials for which the polynomial is a sum-of-squares certificate over domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.WeightedSOSCone","page":"Standard form","title":"SumOfSquares.WeightedSOSCone","text":"struct WeightedSOSCone{\n    M,\n    B<:AbstractPolynomialBasis,\n    G<:AbstractPolynomialBasis,\n    W<:MP.AbstractPolynomialLike,\n} <: MOI.AbstractVectorSet\n    basis::B\n    gram_bases::Vector{G}\n    weights::Vector{W}\nend\n\nThe weighted sum-of-squares cone is the set of vectors of coefficients a in basis that are the sum of weights[i] multiplied by a gram matrix with basis gram_bases[i]. The matrix cone type M is used to decide in which cone the gram matrix is constrained, e.g., MOI.PositiveSemidefiniteConeTriangle or SumOfSquares.ScaledDiagonallyDominantConeTriangle.\n\nSee (Papp and Yıldız, 2017; Section 1.1) and (Kapelevich et al., 2023; Section 1).\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Special cases of positive semidefinite cones:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.EmptyCone\nSumOfSquares.PositiveSemidefinite2x2ConeTriangle","category":"page"},{"location":"reference/standard_form/#SumOfSquares.EmptyCone","page":"Standard form","title":"SumOfSquares.EmptyCone","text":"struct EmptyCone <: MOI.AbstractSymmetricMatrixSetTriangle end\n\nCone of positive semidefinite matrices of 0 rows and 0 columns. It is reformulated into no constraints which is useful as some solvers do not support positive semidefinite cones of dimension zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.PositiveSemidefinite2x2ConeTriangle","page":"Standard form","title":"SumOfSquares.PositiveSemidefinite2x2ConeTriangle","text":"struct PositiveSemidefinite2x2ConeTriangle <: MOI.AbstractSymmetricMatrixSetTriangle end\n\nCone of positive semidefinite matrices of 2 rows and 2 columns. It is reformulated into an MOI.RotatedSecondOrderCone constraint, see for instance (Fawzi, 2018; Equation (1)).\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Inner approximations of the PSD cone that do not require semidefinite programming:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.DiagonallyDominantConeTriangle\nSumOfSquares.ScaledDiagonallyDominantConeTriangle","category":"page"},{"location":"reference/standard_form/#SumOfSquares.DiagonallyDominantConeTriangle","page":"Standard form","title":"SumOfSquares.DiagonallyDominantConeTriangle","text":"struct DiagonallyDominantConeTriangle <: MOI.AbstractSymmetricMatrixSetTriangle\n    side_dimension::Int\nend\n\nSee (Ahmadi and Majumdar, 2017; Definition 4) for a precise definition of the last two items.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#SumOfSquares.ScaledDiagonallyDominantConeTriangle","page":"Standard form","title":"SumOfSquares.ScaledDiagonallyDominantConeTriangle","text":"struct ScaledDiagonallyDominantConeTriangle <: MOI.AbstractSymmetricMatrixSetTriangle\n    side_dimension::Int\nend\n\nSee (Ahmadi and Majumdar, 2017; Definition 4) for a precise definition of the last two items.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#Bridges","page":"Standard form","title":"Bridges","text":"","category":"section"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Bridges are automatically added using the following utilities:","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.PolyJuMP.bridgeable\nSumOfSquares.PolyJuMP.bridges","category":"page"},{"location":"reference/standard_form/#PolyJuMP.bridgeable","page":"Standard form","title":"PolyJuMP.bridgeable","text":"bridgeable(c::JuMP.AbstractConstraint, S::Type{<:MOI.AbstractSet})\n\nWrap the constraint c in JuMP.BridgeableConstraints that may be needed to bridge variables constrained in S on creation.\n\nbridgeable(c::JuMP.AbstractConstraint, F::Type{<:MOI.AbstractFunction},\n           S::Type{<:MOI.AbstractSet})\n\nWrap the constraint c in JuMP.BridgeableConstraints that may be needed to bridge F-in-S constraints.\n\n\n\n\n\n","category":"function"},{"location":"reference/standard_form/#PolyJuMP.bridges","page":"Standard form","title":"PolyJuMP.bridges","text":"bridges(F::Type{<:MOI.AbstractFunction}, S::Type{<:MOI.AbstractSet})\n\nReturn a list of bridges that may be needed to bridge F-in-S constraints but not the bridges that may be needed by constraints added by the bridges.\n\n\n\n\n\nbridges(S::Type{<:MOI.AbstractSet})\n\nReturn a list of bridges that may be needed to bridge variables constrained in S on creation but not the bridges that may be needed by constraints added by the bridges.\n\n\n\n\n\n","category":"function"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Bridges for polynomial optimization","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"PolyJuMP.ScalarPolynomialFunction\nPolyJuMP.Bridges.Objective.ToPolynomialBridge\nPolyJuMP.Bridges.Constraint.ToPolynomialBridge","category":"page"},{"location":"reference/standard_form/#PolyJuMP.ScalarPolynomialFunction","page":"Standard form","title":"PolyJuMP.ScalarPolynomialFunction","text":"struct ScalarPolynomialFunction{T,P<:MP.AbstractPolynomial{T}} <: MOI.AbstractScalarFunction\n    polynomial::P\n    variables::Vector{MOI.VariableIndex}\nend\n\nDefines the polynomial function of the variables variables where the variable variables(p)[i] corresponds to variables[i].\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#PolyJuMP.Bridges.Objective.ToPolynomialBridge","page":"Standard form","title":"PolyJuMP.Bridges.Objective.ToPolynomialBridge","text":"ToPolynomialBridge{T}\n\nToPolynomialBridge implements the following reformulations:\n\nmin f(x) into minp(x)\nmax f(x) into maxp(x)\n\nwhere f(x) is a scalar function and p(x) is a polynomial.\n\nSource node\n\nToPolynomialBridge supports:\n\nMOI.ObjectiveFunction{F} where F is a MOI.AbstractScalarFunction for which convert(::Type{PolyJuMP.ScalarPolynomialFunction}, ::Type{F}). That is for instance the case for MOI.VariableIndex, MOI.ScalarAffineFunction and MOI.ScalarQuadraticFunction.\n\nTarget nodes\n\nToPolynomialBridge creates:\n\nOne objective node: MOI.ObjectiveFunction{PolyJuMP.ScalarPolynomialFunction{T}}\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/#PolyJuMP.Bridges.Constraint.ToPolynomialBridge","page":"Standard form","title":"PolyJuMP.Bridges.Constraint.ToPolynomialBridge","text":"ToPolynomialBridge{T,S} <: Bridges.Constraint.AbstractBridge\n\nToPolynomialBridge implements the following reformulations:\n\nf(x) in S into p(x) in S where f(x) is a scalar function and p(x) is a polynomial.\n\nSource node\n\nToPolynomialBridge supports:\n\nF in S where F is a MOI.AbstractScalarFunction for which\n\nconvert(::Type{PolyJuMP.ScalarPolynomialFunction}, ::Type{F}). That is for    instance the case for MOI.VariableIndex, MOI.ScalarAffineFunction and     MOI.ScalarQuadraticFunction.\n\nTarget nodes\n\nToPolynomialBridge creates:\n\nPolyJuMP.ScalarPolynomialFunction{T} in S\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Sum-of-Squares bridges","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.Bridges.Constraint.ImageBridge","category":"page"},{"location":"reference/standard_form/#SumOfSquares.Bridges.Constraint.ImageBridge","page":"Standard form","title":"SumOfSquares.Bridges.Constraint.ImageBridge","text":"ImageBridge{T,F,G,MT,MVT,CT} <: Bridges.Constraint.AbstractBridge\n\nImageBridge implements a reformulation from SOSPolynomialSet{SemialgebraicSets.FullSpace} into the positive semidefinite cone.\n\nLet Σ be the SOS cone of polynomials of degree 2d and S be the PSD cone. There is a linear relation Σ = A(S). The linear relation reads: p belongs to Σ iff there exists q in S such that A(q) = p. This allows defining a variable bridge that would create variables p and substitute A(q) for p but this is not the purpose of this bridge. This bridge exploit the following alternative read: p belongs to Σ iff there exists q in S such that q in A^-1(p) where A^{-1} is the preimage of p. This preimage can be obtained as A^\\dagger p + \\mathrm{ker}(A) where A^\\dagger is the pseudo-inverse of A. It turns out that for polynomial bases indexed by monomials, A is close to row echelon form so A^\\dagger and \\mathrm{ker}(A) can easily be obtained.\n\nThis is best described in an example. Consider the SOS constraint for the polynomial p = 2x^4 + 2x^3 * y - x^2 * y^2 + 5y^4 with gram basis b = [x^2, y^2, x * y] of (Parrilo, 2003; Example 6.1). The product b * b' is\n\nbeginbmatrix\nx^4  x^2 y^2  x^3 y\nx^2 y^2  y^4  x y^3\nx^3 y  x y^3  x^2 y^2\nendbmatrix\n\nExcept for the entries (1, 2) and (3, 3), all entries are unique so the value of the corresponding gram matrix is given by the corresponding coefficient of p. For the entries (1, 2) and (3, 3), we let -λ be the (1, 2) and (3, 3) entries and we add 2λ for the (3, 3) entry so as to parametrize entries for which the sum is the corresponding coefficient in p, i.e., -1. The gram matrix is therefore:\n\nbeginbmatrix\n2  -lambda  1\n-lambda  5  0\n1  0  2lambda - 1\nendbmatrix\n\nSource node\n\nImageBridge supports:\n\nH in SOSPolynomialSet{SemialgebraicSets.FullSpace}\n\nTarget nodes\n\nImageBridge creates one of the following, depending on the length of the gram basis:\n\nF in MOI.PositiveSemidefiniteConeTriangle, for gram basis of length at least 3\nF in SumOfSquares.PositiveSemidefinite2x2ConeTriangle, for gram basis of length 2\nF in MOI.Nonnegatives, for gram basis of length 1\nF in SumOfSquares.EmptyCone, for empty gram basis\n\nin addition to\n\na constraint G in MOI.Zeros in case there is a monomial in s.monomials that cannot be obtained as product of elements in a gram basis.\n\n\n\n\n\n","category":"type"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"Bridges for PSD cone approximations","category":"page"},{"location":"reference/standard_form/","page":"Standard form","title":"Standard form","text":"SumOfSquares.Bridges.Variable.ScaledDiagonallyDominantBridge","category":"page"},{"location":"reference/standard_form/#SumOfSquares.Bridges.Variable.ScaledDiagonallyDominantBridge","page":"Standard form","title":"SumOfSquares.Bridges.Variable.ScaledDiagonallyDominantBridge","text":"struct ScaledDiagonallyDominantBridge{T} <: MOI.Bridges.Variable.AbstractBridge\n    side_dimension::Int\n    variables::Vector{Vector{MOI.VariableIndex}}\n    constraints::Vector{MOI.ConstraintIndex{\n        MOI.VectorOfVariables, SOS.PositiveSemidefinite2x2ConeTriangle}}\nend\n\nA matrix is SDD iff it is the sum of psd matrices Mij that are zero except for entries ii, ij and jj (Ahmadi and Majumdar, 2017; Lemma 9). This bridge substitute the constrained variables in SOS.ScaledDiagonallyDominantConeTriangle into a sum of constrained variables in SOS.PositiveSemidefinite2x2ConeTriangle.\n\n\n\n\n\n","category":"type"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"EditURL = \"../../tutorials/Symmetry/dihedral.jl\"","category":"page"},{"location":"generated/Symmetry/dihedral/#Dihedral-symmetry-of-the-Robinson-form","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"","category":"section"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"(Image: ) (Image: ) Adapted from: Example 5.4 of [GP04]","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"[GP04] Gatermann, Karin and Parrilo, Pablo A. Symmetry groups, semidefinite programs, and sums of squares. Journal of Pure and Applied Algebra 192.1-3 (2004): 95-128.","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"We start by defining the Dihedral group of order 8. This group is isomorphic to the following permutation group:","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"using PermutationGroups\nd = perm\"(1, 2, 3, 4)\"\nc = perm\"(1, 3)\"\nG = PermGroup([c, d])","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"We could rely on this isomorphism to define this group. However, in order to illustrate how to do symmetry reduction with a custom group, we show in this example what should be implemented to define a new group.","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"import GroupsCore\n\nstruct DihedralGroup <: GroupsCore.Group\n    n::Int\nend\n\nstruct DihedralElement <: GroupsCore.GroupElement\n    n::Int\n    reflection::Bool\n    id::Int\nend","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"Implementing GroupsCore API:","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"Base.one(G::DihedralGroup) = DihedralElement(G.n, false, 0)\n\nBase.eltype(::Type{DihedralGroup}) = DihedralElement\nBase.IteratorSize(::Type{DihedralGroup}) = Base.HasLength()\n\nfunction Base.iterate(G::DihedralGroup, prev::DihedralElement=DihedralElement(G.n, false, -1))\n    if prev.id + 1 >= G.n\n        if prev.reflection\n            return nothing\n        else\n            next = DihedralElement(G.n, true, 0)\n        end\n    else\n        next = DihedralElement(G.n, prev.reflection, prev.id + 1)\n    end\n    return next, next\nend\n\nGroupsCore.order(::Type{T}, G::DihedralGroup) where {T} = convert(T, 2G.n)\nGroupsCore.gens(G::DihedralGroup) = [DihedralElement(G.n, false, 1), DihedralElement(G.n, true, 0)]","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"Base.rand not needed for our purposes here","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"Base.parent(g::DihedralElement) = DihedralGroup(g.n)\nfunction Base.:(==)(g::DihedralElement, h::DihedralElement)\n    return g.n == h.n && g.reflection == h.reflection && g.id == h.id\nend\n\nfunction Base.inv(el::DihedralElement)\n    if el.reflection || iszero(el.id)\n        return el\n    else\n        return DihedralElement(el.n, false, el.n - el.id)\n    end\nend\nfunction Base.:*(a::DihedralElement, b::DihedralElement)\n    a.n == b.n || error(\"Cannot multiply elements from different Dihedral groups\")\n    id = mod(a.reflection ? a.id - b.id : a.id + b.id, a.n)\n    return DihedralElement(a.n, a.reflection != b.reflection, id)\nend\n\nBase.copy(a::DihedralElement) = DihedralElement(a.n, a.reflection, a.id)","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"optional functions:","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"function GroupsCore.order(el::DihedralElement)\n    if el.reflection\n        return 2\n    else\n        if iszero(el.id)\n            return 1\n        else\n            return div(el.n, gcd(el.n, el.id))\n        end\n    end\nend","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"The Robinson form is invariant under the following action of the Dihedral group on monomials: The action of each element of the groups is to map the variables x, y to:","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"id rotation reflection\n0 x, y y, x\n1 -y, x -x, y\n2 -x, -y -y, -x\n3 y, -x x, -y","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"using SumOfSquares\nusing DynamicPolynomials\n@polyvar x y\nstruct DihedralAction <: Symmetry.OnMonomials end\nimport SymbolicWedderburn\nSymbolicWedderburn.coeff_type(::DihedralAction) = Float64\nfunction SymbolicWedderburn.action(::DihedralAction, el::DihedralElement, mono::AbstractMonomial)\n    if iseven(el.reflection + el.id)\n        var_x, var_y = x, y\n    else\n        var_x, var_y = y, x\n    end\n    sign_x = 1 <= el.id <= 2 ? -1 : 1\n    sign_y = 2 <= el.id ? -1 : 1\n    return mono([x, y] => [sign_x * var_x, sign_y * var_y])\nend\n\npoly = x^6 + y^6 - x^4 * y^2 - y^4 * x^2 - x^4 - y^4 - x^2 - y^2 + 3x^2 * y^2 + 1","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"We can verify that poly is indeed invariant under the action of each element of the group as follows.","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"G = DihedralGroup(4)\nfor g in G\n    @show SymbolicWedderburn.action(DihedralAction(), g, poly)\nend","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"We can exploit this symmetry for reducing the problem using the SymmetricIdeal certificate as follows:","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"import CSDP\nfunction solve(G)\n    solver = CSDP.Optimizer\n    model = Model(solver)\n    @variable(model, t)\n    @objective(model, Max, t)\n    pattern = Symmetry.Pattern(G, DihedralAction())\n    con_ref = @constraint(model, poly - t in SOSCone(), symmetry = pattern)\n    optimize!(model)\n    @show value(t)\n\n\n    for g in gram_matrix(con_ref).blocks\n        println(g.basis.polynomials)\n    end\nend\nsolve(G)","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"We notice that we indeed find -3825/4096 and that symmetry was exploited.","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"","category":"page"},{"location":"generated/Symmetry/dihedral/","page":"Dihedral symmetry of the Robinson form","title":"Dihedral symmetry of the Robinson form","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"EditURL = \"../../tutorials/Polynomial Optimization/polynomial_optimization.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#Polynomial-Optimization","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#Introduction","page":"Polynomial Optimization","title":"Introduction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Consider the polynomial optimization problem (Lasserre, 2009; Example 2.2) of minimizing the polynomial x^3 - x^2 + 2xy - y^2 + y^3 over the polyhedron defined by the inequalities x ge 0 y ge 0 and x + y geq 1.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"using DynamicPolynomials\n@polyvar x y\np = x^3 - x^2 + 2x*y -y^2 + y^3\nusing SumOfSquares\nS = @set x >= 0 && y >= 0 && x + y >= 1\np(x=>1, y=>0), p(x=>1//2, y=>1//2), p(x=>0, y=>1)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#Local-search","page":"Polynomial Optimization","title":"Local search","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"A local solver only uses the local information given by the the value, gradient and hessian of the objective function and constraints at a given solution. When it converges, it therefore only guarantees that the found solution is a local minimum. In this example, the optimal solutions are (x y) = (1 0) and (x y) = (0 1) with objective value 0 but Ipopt only finds the local minimum (12 12) with objective value 14.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"import Ipopt\nmodel = Model(Ipopt.Optimizer)\n@variable(model, a >= 0)\n@variable(model, b >= 0)\n@constraint(model, a + b >= 1)\n@NLobjective(model, Min, a^3 - a^2 + 2a*b - b^2 + b^3)\noptimize!(model)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"As we can see below, the termination status is LOCALLY_SOLVED and not of OPTIMAL because Ipopt only guarantees local optimality.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"solution_summary(model)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Indeed, the solution found is not globally optimal:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"value(a), value(b)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Note that the problem can be written equivalently as follows using registered functions. The difference is that the gradient and hessian will be computed via the Symbolic Differentiation provided by MultivariatePolynomials instead of JuMP's Automatic Differentiation:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"f(a, b) = p(x => a, y => b)\n∇p = differentiate(p, [x, y])\nfunction ∇f(g, a, b)\n    for i in eachindex(g)\n        g[i] = ∇p[i](x => a, y => b)\n    end\nend\n∇²p = differentiate(∇p, [x, y])\nfunction ∇²f(H, a, b)\n    for j in axes(∇²p, 2)\n        for i in j:size(∇²p, 1)\n            H[i, j] = ∇²p[i, j](x => a, y => b)\n        end\n    end\nend\nusing Ipopt\ngmodel = Model(Ipopt.Optimizer)\n@variable(gmodel, a >= 0)\n@variable(gmodel, b >= 0)\n@constraint(gmodel, a + b >= 1)\nregister(gmodel, :f, 2, f, ∇f, ∇²f)\n@NLobjective(gmodel, Min, f(a, b))\noptimize!(gmodel)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Even if we have the algebraic expressions of gradient and hessian, Ipopt is not using these symbolic expressions but only local information hence it can still only provide local guarantees:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"solution_summary(gmodel)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"and the same solution is found:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"value(a), value(b)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#Sum-of-Squares-approach","page":"Polynomial Optimization","title":"Sum-of-Squares approach","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"import SCS\nscs = SCS.Optimizer\nimport Dualization\ndual_scs = Dualization.dual_optimizer(scs)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following program searches for the largest lower bound and finds zero.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"model = SOSModel(dual_scs)\n@variable(model, α)\n@objective(model, Max, α)\n@constraint(model, c3, p >= α, domain = S)\noptimize!(model)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This time, the termination status is OPTIMAL but this does not necessarily mean that we found the optimal solution to the polynomial optimization problem. This only means that CSDP founds an optimal solution to the Sum-of-Squares relaxation.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"solution_summary(model)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The feasibility of the primal solution guarantees that the objective value 0 is a lower bound to the polynomial optimization problem. The optimality means that it's the best lower bound we can get (at this degree of the hierarcy). Using the solution (12 12) found by Ipopt of objective value 14 and this certificate of lower bound 0 we know that the optimal objective value is in the interval 0 14 but we still do not know what it is (if we consider that we did not try the solutions (1 0) and (0 1) as done in the introduction). If the dual of the constraint c3 was atomic, its atoms would have given optimal solutions of objective value 0 but that is not the case.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν3 = moment_matrix(c3)\natomic_measure(ν3, 1e-3) # Returns nothing as the dual is not atomic","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Fortunately, there is a hierarchy of programs with increasingly better bounds that can be solved until we get one with atom dual variables. This comes from the way the Sum-of-Squares constraint with domain S is formulated. The polynomial p - alpha is guaranteed to be nonnegative over the domain S if there exists Sum-of-Squares polynomials s_0, s_1, s_2, s_3 such that","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"p - alpha = s_0 + s_1 x + s_2 y + s_3 (x + y - 1)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Indeed, in the domain S, x, y and x + y - 1 are nonnegative so the right-hand side is a sum of squares hence is nonnegative. Once the degrees of s_1, s_2 and s_3 have been decided, the degree needed for s_0 will be determined but we have a freedom in choosing the degrees of s_1, s_2 and s_3. By default, they are chosen so that the degrees of s_1 x, s_2 y and s_3 (x + y - 1) match those of p - alpha but this can be overwritten using the maxdegree keyword argument.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#The-maxdegree-keyword-argument","page":"Polynomial Optimization","title":"The maxdegree keyword argument","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The maximum total degree (i.e. maximum sum of the exponents of x and y) of the monomials of p is 3 so the constraint in the program above is equivalent to @constraint(model, p >= α, domain = S, maxdegree = 3). That is, since x, y and x + y - 1 have total degree 1, the sum of squares polynomials s_1, s_2 and s_3 have been chosen with maximum total degree 2. Since these polynomials are sums of squares, their degree must be even so the next maximum total degree to try is 4. For this reason, the keywords maxdegree = 4 and maxdegree = 5 have the same effect in this example. In general, if the polynomials in the domain are not all odd or all even, each value of maxdegree has a different effect in the choice of the maximum total degree of some s_i.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"model = SOSModel(dual_scs)\n@variable(model, α)\n@objective(model, Max, α)\n@constraint(model, c4, p >= α, domain = S, maxdegree = 4)\noptimize!(model)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"We can see that the basis of the moment matrix didn't increase:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"moment_matrix(c4)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This is because of the Newton polytope reduction that determined that gram matrix will be zero for these degrees so it reduced the problem back to the equivalent of maxdegree 3 Let's turn this off with newton_polytope = nothing","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"function sos(solver, deg)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = S, maxdegree = deg, newton_polytope = nothing)\n    optimize!(model)\n    return model\nend\ndual_model4 = sos(dual_scs, 4)\nnothing #hide","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"We see that the lower bound is still 0:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"solution_summary(dual_model4)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Let's now look at which solution we can extract from the moment matrix:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"dual_ν4 = moment_matrix(dual_model4[:c])","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Looking at the singular values, 4 seems to be a reasonable rank:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"using LinearAlgebra\nsvdvals(Matrix(dual_ν4.Q))","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The solution we extract is (0.5, 0.5) which is the solution found by Ipopt:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"atomic_measure(dual_ν4, FixedRank(4))","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This process is quite sensitive numerically so let's try to solve it without dualization as well:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"model4 = sos(scs, 4)\nnothing #hide","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"We see that the lower bound is again 0:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"solution_summary(model4)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The moment matrix is the following","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν4 = moment_matrix(model4[:c])","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Looking at the singular values, 3 seems to be a reasonable rank:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"svdvals(Matrix(ν4.Q))","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This time, the dual variable is atomic as it is the moments of the measure 05 delta(x-1 y) + 05 delta(x y-1) where delta(x y) is the dirac measure centered at (0 0). Therefore the program provides both a certificate that 0 is a lower bound and a certificate that it is also an upper bound since it is attained at the global minimizers (1 0) and (0 1).","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"atomic_measure(ν4, FixedRank(3))","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#A-deeper-look-into-atom-extraction","page":"Polynomial Optimization","title":"A deeper look into atom extraction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The moment matrix is transformed into a system of polynomials equations whose solutions give the atoms. This transformation uses the SVD decomposition of the moment matrix and discards the equations corresponding to the lowest singular values. When this system of equation has an infinite number of solutions, atomic_measure concludes that the measure is not atomic. For instance, with maxdegree = 3, we obtain the system x + y = 1 which contains a whole line of solution. This explains atomic_measure returned nothing.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν3 = moment_matrix(c3)\nSumOfSquares.MultivariateMoments.compute_support!(ν3, LeadingRelativeRankTol(1e-3))","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"With maxdegree = 4, we obtain the system","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"beginaligned\n  x + y  = 1\n  y^2  = y\n  xy  = 0\n  -y + y^2 - x*y  = 0\n  y^2 - 2y + 1  = x^2\nendaligned","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν4 = moment_matrix(model4[:c])\nSumOfSquares.MultivariateMoments.compute_support!(ν4, FixedRank(3))","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This system can be reduced to the equivalent system","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"beginaligned\n  x + y  = 1\n  y^2  = y\nendaligned","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"which has the solutions (0 1) and (1 0).","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"SemialgebraicSets.compute_gröbner_basis!(ideal(ν4.support))\nν4.support","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The solutions of this system then give the minimizers","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"collect(ν4.support)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The function atomic_measure then reuses the matrix of moments to find the weights 12, 12 corresponding to the diracs centered respectively at (0 1) and (1 0). This details how the function obtained the result 05 delta(x-1 y) + 05 delta(x y-1) given in the previous section.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/#HomotopyContinuation","page":"Polynomial Optimization","title":"HomotopyContinuation","text":"","category":"section"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"As discussed in the previous section, the atom extraction relies on the solution of a system of algebraic equations. The atomic_measure function takes an optional algebraic_solver argument that is used to solve this system of equation. If no solver is provided, the default solver of SemialgebraicSets.jl is used which currently computes the Gröbner basis, then the multiplication matrices and then the Schur decomposition of a random combination of these matrices. As the system of equations is obtained from a numerical solution and is represented using floating point coefficients, homotopy continuation is recommended as it is more numerically robust than Gröbner basis computation. The following uses homotopy continuation to solve the system of equations.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"using HomotopyContinuation\nalgebraic_solver = SemialgebraicSetsHCSolver(; excess_residual_tol = 1e-1, real_tol = 1e-1, compile = false)\natomic_measure(ν4, FixedRank(3), Echelon(), algebraic_solver)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"As the system has 3 equations for 2 variables and the coefficients of the equations are to be treated with tolerance since they originate from the solution of an SDP, we need to set excess_residual_tol and real_tol to a high tolerance otherwise, HomotopyContinuation would consider that there is no solution. Indeed, as the system is overdetermined (it has more equations than variables) HomotopyContinuation expects to have excess solution hence it filters out excess solution among the solution found. It determines which solution are in excess by comparing the infinity norm of the residuals of the equations at the solution with excess_residual_tol. It also filters out solution for which the absolute value of the imaginary part of one of the entry is larger than real_tol and strips out the imaginary part. The raw solutions obtained by HomotopyContinuation can be obtained as follows:","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"F = HomotopyContinuation.System(ν4.support)\nres = HomotopyContinuation.solve(F, algebraic_solver.options...)\npath_results(res)","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The printed residual above shows why 1e-1 allows to filter how the 2 actual solutions from the 2 excess solutions.","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"","category":"page"},{"location":"generated/Polynomial Optimization/polynomial_optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"EditURL = \"../../tutorials/Polynomial Optimization/min_univariate.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/#Maximizing-as-minimum","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"","category":"section"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"(Image: ) (Image: ) Adapted from: (Floudas et al., 1999; Section 4.10), (Laurent, 2008; Example 6.23) and (Lasserre, 2009; Table 5.1)","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/#Introduction","page":"Maximizing as minimum","title":"Introduction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"Consider the polynomial optimization problem from (Floudas et al., 1999; Section 4.10) of minimizing the linear function -x_1 - x_2 over the basic semialgebraic set defined by the inequalities x_2 le 2x_1^4 - 8x_1^3 + 8x_1^2 + 2, x_2 le 4x_1^4 - 32x_1^3 + 88x_1^2 - 96x_1 + 36 and the box constraints 0 le x_1 le 3 and 0 le x_2 le 4,","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"using DynamicPolynomials\n@polyvar x[1:2]\np = -sum(x)\nusing SumOfSquares\nf1 = 2x[1]^4 - 8x[1]^3 + 8x[1]^2 + 2\nf2 = 4x[1]^4 - 32x[1]^3 + 88x[1]^2 - 96x[1] + 36\nK = @set x[1] >= 0 && x[1] <= 3 && x[2] >= 0 && x[2] <= 4 && x[2] <= f1 && x[2] <= f2","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"As we can observe below, the bounds on x[2] could be dropped and optimization problem is equivalent to the maximization of min(f1, f2) between 0 and 3.","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"xs = range(0, stop = 3, length = 100)\nusing Plots\nplot(xs, f1.(xs), label = \"f1\")\nplot!(xs, f2.(xs), label = \"f2\")\nplot!(xs, 4 * ones(length(xs)), label = nothing)","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"import Clarabel\nsolver = Clarabel.Optimizer","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following function searches for the largest lower bound and finds zero using the dth level of the hierarchy`.","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"function solve(d)\n    model = SOSModel(solver)\n    @variable(model, α)\n    @objective(model, Max, α)\n    @constraint(model, c, p >= α, domain = K, maxdegree = d)\n    optimize!(model)\n    println(solution_summary(model))\n    return model\nend","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"The first level of the hierarchy gives a lower bound of -7`","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"model4 = solve(4)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"The second level improves the lower bound","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"model5 = solve(5)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"The third level finds the optimal objective value as lower bound...","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"model7 = solve(7)\nnothing # hide","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"...and proves it by exhibiting the minimizer.","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"ν7 = moment_matrix(model7[:c])\nη = atomic_measure(ν7, 1e-3) # Returns nothing as the dual is not atomic","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"We can indeed verify that the objective value at x_opt is equal to the lower bound.","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"x_opt = η.atoms[1].center\np(x_opt)","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"We can see visualize the solution as follows:","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"scatter!([x_opt[1]], [x_opt[2]], markershape = :star, label = nothing)","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"","category":"page"},{"location":"generated/Polynomial Optimization/min_univariate/","page":"Maximizing as minimum","title":"Maximizing as minimum","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Ahmadi, A. A. and Majumdar, A. (2017). DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization. ArXiv e-prints, arXiv:1706.02586 [math.OC].\n\n\n\nBlekherman, G.; Parrilo, P. A. and Thomas, R. R. (2012). Semidefinite Optimization and Convex Algebraic Geometry (Society for Industrial and Applied Mathematics, Philadelphia, PA), arXiv:http://epubs.siam.org/doi/pdf/10.1137/1.9781611972290.\n\n\n\nCox, D. A.; Little, J. and O'Shea, D. (2015). Ideals, Varieties, and Algorithms (Springer).\n\n\n\nFawzi, H. (2018). On Representing the Positive Semidefinite Cone Using the Second-Order Cone. Mathematical Programming, 1–10.\n\n\n\nFloudas, C. A.; Pardalos, P. M.; Adjiman, C. S.; Esposito, W. R.; Gümüş, Z. H.; Harding, S. T.; Klepeis, J. L.; Meyer, C. A. and Schweiger, C. A. (1999). Handbook of Test Problems in Local and Global Optimization (Springer US).\n\n\n\nHesse, R. (1973). A Heuristic Search Procedure for Estimating a Global Solution of Nonconvex Programming Problems. Operations Research 21, 1267–1280.\n\n\n\nKapelevich, L.; Coey, C. and Vielma, J. P. (2023). Sum of Squares Generalizations for Conic Sets. Mathematical Programming 199, 1417–1429.\n\n\n\nLasserre, J. B. (2009). Moments, Positive Polynomials and Their Applications (Imperial College Press).\n\n\n\nLaurent, M. (2008). Sums of Squares, Moment Matrices and Optimization Over Polynomials. In: The IMA Volumes in Mathematics and its Applications (Springer New York); pp. 157–270.\n\n\n\nMurty, K. G. and Kabadi, S. N. (1987). Some NP-complete Problems in Quadratic and Nonlinear Programming. Mathematical Programming: Series A and B 39, 117–129.\n\n\n\nPapp, D. and Yıldız, S. (2017). Sum-of-Squares Optimization without Semidefinite Programming. ArXiv e-prints, arXiv:1712.01792 [math.OC].\n\n\n\nParrilo, P. A. (2003). Semidefinite Programming Relaxations for Semialgebraic Problems. Mathematical programming 96, 293–320.\n\n\n\n","category":"page"},{"location":"#SumOfSquares-–-Sum-of-Squares-Programming-for-Julia","page":"Index","title":"SumOfSquares –- Sum of Squares Programming for Julia","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"SumOfSquares implements Sum of Squares reformulation for PolyJuMP, enabling the creation of sum of squares variables and constraints in JuMP.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The polynomial can be represented by any library implementing the MultivariatePolynomial.jl interface. That is, you can currently choose between DynamicPolynomials and TypedPolynomials. As a rule of thumb, if you know at compile time (or at the time you are writing your code), the number of variable and that this number is small, use TypedPolynomials, otherwise, use DynamicPolynomials.","category":"page"},{"location":"#Contents","page":"Index","title":"Contents","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages = [\"sumofsquares.md\", \"variables.md\", \"constraints.md\"]\nDepth = 2","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"EditURL = \"../../tutorials/Extension/univariate_solver.jl\"","category":"page"},{"location":"generated/Extension/univariate_solver/#Univariate-Solver","page":"Univariate Solver","title":"Univariate Solver","text":"","category":"section"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"When using an SDP solver, the Sum-of-Squares constraint is bridged into a semidefinite constraint. This reformulation is done only if the solver does not support the Sum-of-Squares constraint. We show in this tutorial how to define a solver that supports such constraint. The same model with be then solved with or without reformulation depending on the solver.","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"We consider a solver that would support finding the SOS decomposition of nonnegative univariate polynomials.","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"module MyUnivariateSolver\n\nimport LinearAlgebra\nimport MathOptInterface as MOI\nimport MultivariatePolynomials as MP\nimport SumOfSquares as SOS\n\nfunction decompose(p::MP.AbstractPolynomial, tol=1e-6)\n    vars = MP.effective_variables(p)\n    if length(vars) != 1\n        error(\"$p is not univariate\")\n    end\n    x = first(vars)\n    lead = MP.leading_coefficient(p)\n    if !isone(lead)\n        p = p / lead\n    end\n    deg = MP.maxdegree(p)\n    if isodd(deg)\n        return\n    end\n    d = div(deg, 2)\n    companion = zeros(2d, 2d)\n    for i in 0:(2d-1)\n        if i > 0\n            companion[i + 1, i] = 1.0\n        end\n        companion[i + 1, end] = -MP.coefficient(p, x^i)\n    end\n    F = LinearAlgebra.schur(complex(companion))\n    q = one(p)\n    i = 1\n    while i <= length(F.values)\n        root = F.values[i]\n        q *= (x - root)\n        if !isapprox(real(root), real(F.values[i+1]), rtol=tol, atol=tol)\n            return # Cannot happen for complex conjugate root so it means that we have a root which does not have an even multiplicity This means that the polynomial is not nonnegative\n        end\n        i += 2\n    end\n    q1 = MP.map_coefficients(real, q)\n    q2 = MP.map_coefficients(imag, q)\n    return SOS.SOSDecomposition([q1, q2])\nend\n\nmutable struct Optimizer <: MOI.AbstractOptimizer\n    p::Union{Nothing,MP.AbstractPolynomial}\n    decomposition::Union{Nothing,SOS.SOSDecomposition}\n    tol::Float64\n    function Optimizer()\n        return new(nothing, nothing, 1e-6)\n    end\nend\n\nMOI.is_empty(optimizer::Optimizer) = optimizer.p === nothing\nfunction MOI.empty!(optimizer::Optimizer)\n    optimizer.p = nothing\n    return\nend\n\nfunction MOI.supports_constraint(::Optimizer, ::Type{<:MOI.VectorAffineFunction}, ::Type{<:SOS.SOSPolynomialSet{SOS.FullSpace}})\n    return true\nend\nfunction MOI.add_constraint(optimizer::Optimizer, func::MOI.VectorAffineFunction, set::SOS.SOSPolynomialSet{SOS.FullSpace})\n    if optimizer.p !== nothing\n        error(\"Only one constraint is supported\")\n    end\n    if !isempty(func.terms)\n        error(\"Only supports constant polynomials\")\n    end\n    optimizer.p = MP.polynomial(func.constants, set.monomials)\n    return MOI.ConstraintIndex{typeof(func),typeof(set)}(1) # There will be only ever one constraint so the index does not matter.\nend\n\nMOI.supports_incremental_interface(::Optimizer) = true\nfunction MOI.copy_to(optimizer::Optimizer, model::MOI.ModelLike)\n    return MOI.Utilities.default_copy_to(optimizer, model)\nend\nfunction MOI.optimize!(optimizer::Optimizer)\n    optimizer.decomposition = decompose(optimizer.p, optimizer.tol)\nend\n\nfunction MOI.get(optimizer::Optimizer, ::MOI.TerminationStatus)\n    if optimizer.decomposition === nothing\n        return MOI.INFEASIBLE\n    else\n        return MOI.OPTIMAL\n    end\nend\n\nfunction MOI.get(optimizer::Optimizer, ::MOI.PrimalStatus)\n    if optimizer.decomposition === nothing\n        return MOI.NO_SOLUTION\n    else\n        return MOI.FEASIBLE_POINT\n    end\nend\n\nfunction MOI.get(optimizer::Optimizer, ::SOS.SOSDecompositionAttribute, ::MOI.ConstraintIndex)\n    return optimizer.decomposition\nend\n\nend","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"We define the same function both for our new solver and SDP solvers.","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"using SumOfSquares\nfunction decompose(p, solver)\n    model = Model(solver)\n    con = @constraint(model, p in SOSCone())\n    optimize!(model)\n    @assert primal_status(model) == MOI.FEASIBLE_POINT\n    return sos_decomposition(con)\nend","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"We consider the following univariate polynomial from (Blekherman et al., 2012; Example 3.35).","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"Using our solver we find the following decomposition in two squares.","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"using DynamicPolynomials\n@polyvar x\np = x^4 + 4x^3 + 6x^2 + 4x + 5\ndec = decompose(p, MyUnivariateSolver.Optimizer)","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"We can verify as follows that it gives a correct decomposition:","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"polynomial(dec)","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"We can also use a semidefinite solver:","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"import CSDP\ndec = decompose(p, CSDP.Optimizer)","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"The decomposition is different, it is the sum of 3 squares. However, it is also valid:","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"polynomial(dec)","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"","category":"page"},{"location":"generated/Extension/univariate_solver/","page":"Univariate Solver","title":"Univariate Solver","text":"This page was generated using Literate.jl.","category":"page"}]
}
