<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Viability tube for quadrotor · SumOfSquares</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">SumOfSquares</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Index</a></li><li><a class="tocitem" href="../../../sumofsquares/">Sum-of-Squares Programming</a></li><li><a class="tocitem" href="../../../variables/">Variables</a></li><li><a class="tocitem" href="../../../constraints/">Constraints</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Getting started/circle/">Nonnegative over a variety</a></li><li><a class="tocitem" href="../../Getting started/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../Getting started/motzkin/">Motzkin</a></li><li><a class="tocitem" href="../../Getting started/sos_decomposition/">A trivial SOS decomposition example</a></li><li><a class="tocitem" href="../../Getting started/sum-of-squares_matrices/">Sum-of-Squares matrices</a></li><li><a class="tocitem" href="../../Getting started/univariate/">Minimization of a univariate polynomial</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Polynomial Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Polynomial Optimization/bound_on_global_extremum/">Bound on Global Extremum</a></li><li><a class="tocitem" href="../../Polynomial Optimization/extracting_minimizers/">Extracting minimizers</a></li><li><a class="tocitem" href="../../Polynomial Optimization/polynomial_optimization/">Polynomial Optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox" checked/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Systems and Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../julia_set/">Outer approximation of Julia set</a></li><li><a class="tocitem" href="../lyapunov_function_search/">Lyapunov Function Search</a></li><li class="is-active"><a class="tocitem" href>Viability tube for quadrotor</a></li><li><a class="tocitem" href="../stabilization_of_nonlinear_systems/">Stabilization of nonlinear systems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Other Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Other Applications/bounds_in_probability/">Bounds in Probability</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Noncommutative and Hermitian</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Noncommutative and Hermitian/noncommutative_variables/">Noncommutative variables</a></li><li><a class="tocitem" href="../../Noncommutative and Hermitian/sums_of_hermitian_squares/">Sums of Hermitian squares</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Sparsity</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Sparsity/sign_symmetry/">Sign symmetry</a></li><li><a class="tocitem" href="../../Sparsity/term_sparsity/">Term sparsity</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Symmetry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Symmetry/cyclic/">Cyclic symmetry for Sums of Hermitian Squares</a></li><li><a class="tocitem" href="../../Symmetry/dihedral_symmetry_of_the_robinson_form/">Dihedral symmetry of the Robinson form</a></li><li><a class="tocitem" href="../../Symmetry/even_reduction/">Even reduction</a></li><li><a class="tocitem" href="../../Symmetry/permutation_symmetry/">Symmetry reduction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">Extension</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Extension/certificate/">Certificate</a></li><li><a class="tocitem" href="../../Extension/hypercube/">Hypercube</a></li><li><a class="tocitem" href="../../Extension/typed/">Multivariate polynomials implementations</a></li><li><a class="tocitem" href="../../Extension/univariate_solver/">Univariate Solver</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Systems and Control</a></li><li class="is-active"><a href>Viability tube for quadrotor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Viability tube for quadrotor</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/SumOfSquares.jl/blob/master/docs/src/tutorials/Systems and Control/quadrotor.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Viability-tube-for-quadrotor"><a class="docs-heading-anchor" href="#Viability-tube-for-quadrotor">Viability tube for quadrotor</a><a id="Viability-tube-for-quadrotor-1"></a><a class="docs-heading-anchor-permalink" href="#Viability-tube-for-quadrotor" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/jump-dev/SumOfSquares.jl/gh-pages?filepath=previews/PR274/generated/Systems and Control/quadrotor.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/jump-dev/SumOfSquares.jl/blob/gh-pages/previews/PR274/generated/Systems and Control/quadrotor.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a> <strong>Adapted from</strong>: [YAP21, Section V.D] for the model defined in [B12], [M16, Section IV] and [M19, Section 6.1]</p><p>[B12] Bouffard, Patrick. <em>On-board model predictive control of a quadrotor helicopter: Design, implementation, and experiments.</em> CALIFORNIA UNIV BERKELEY DEPT OF COMPUTER SCIENCES, 2012.</p><p>[M16] Mitchell, Ian M., et al. <em>Ensuring safety for sampled data systems: An efficient algorithm for filtering potentially unsafe input signals.</em> 2016 IEEE 55th Conference on Decision and Control (CDC). IEEE, 2016.</p><p>[M19] Mitchell, Ian M., Jacob Budzis, and Andriy Bolyachevets. <em>Invariant, viability and discriminating kernel under-approximation via zonotope scaling.</em> Proceedings of the 22nd ACM International Conference on Hybrid Systems: Computation and Control. 2019.</p><p>[YAP21] Yin, H., Arcak, M., Packard, A., &amp; Seiler, P. (2021). <em>Backward reachability for polynomial systems on a finite horizon.</em> IEEE Transactions on Automatic Control, 66(12), 6025-6032.</p><pre><code class="language-julia hljs">using DynamicPolynomials
@polyvar x[1:6]
@polyvar u[1:2]
sinx5 = -0.166 * x[5]^3 + x[5]
cosx5 = -0.498 * x[5]^2 + 1
gn = 9.8
K = 0.89 / 1.4
d0 = 70
d1 = 17
n0 = 55
f = [
    x[3],
    x[4],
    0,
    -gn,
    x[6],
    -d0 * x[5] - d1 * x[6],
]
n_x = length(f)
g = [
    0         0
    0         0
    K * sinx5 0
    K * cosx5 0
    0         0
    0         n0
]
n_u = size(g, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>The constraints below are the same as [YAP21, M16, M19] except [M16, M19] uses different bounds for <code>x[2]</code> and [M16] uses different bounds for <code>x[5]</code></p><pre><code class="language-julia hljs">using SumOfSquares
rectangle = [1.7, 0.85, 0.8, 1, π/12, π/2, 1.5, π/12]
X = BasicSemialgebraicSet(FullSpace(), typeof(x[1] + 1.0)[])
for i in eachindex(x)
    addinequality!(X, x[i] + rectangle[i]) # x[i] &gt;= -rectangle[i]
    addinequality!(X, rectangle[i] - x[i]) # x[i] &lt;= rectangle[i]
end
X</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Basic semialgebraic Set defined by no equality
12 inequalities
 x[1] + 1.7 ≥ 0
 -x[1] + 1.7 ≥ 0
 x[2] + 0.85 ≥ 0
 -x[2] + 0.85 ≥ 0
 x[3] + 0.8 ≥ 0
 -x[3] + 0.8 ≥ 0
 x[4] + 1.0 ≥ 0
 -x[4] + 1.0 ≥ 0
 x[5] + 0.2617993877991494 ≥ 0
 -x[5] + 0.2617993877991494 ≥ 0
 x[6] + 1.5707963267948966 ≥ 0
 -x[6] + 1.5707963267948966 ≥ 0
</code></pre><p>The starting value for <code>k</code> is the following linear state-feedback that maintains the quadrotor at the origin [YAP21, Remark 3].</p><p>For this, we compute an ellipsoidal control invariant set using [LJ21, Corollary 9] For this, we first compute the descriptor system described in [LJ21, Proposition 5].</p><p>[LJ21] Legat, Benoît, and Jungers, Raphaël M. <em>Geometric control of algebraic systems.</em> IFAC-PapersOnLine 54.5 (2021): 79-84.</p><pre><code class="language-julia hljs">using SparseArrays
x0 = zeros(n_x)
u0 = [gn/K, 0.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 15.415730337078651
  0.0</code></pre><p>The linearization of <code>f</code> is given by</p><pre><code class="language-julia hljs">A = map(differentiate(f, x)) do f
    f(x =&gt; x0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 Matrix{Float64}:
 0.0  0.0  1.0  0.0    0.0    0.0
 0.0  0.0  0.0  1.0    0.0    0.0
 0.0  0.0  0.0  0.0    0.0    0.0
 0.0  0.0  0.0  0.0    0.0    0.0
 0.0  0.0  0.0  0.0    0.0    1.0
 0.0  0.0  0.0  0.0  -70.0  -17.0</code></pre><p>The linearization of <code>g</code> is given by:</p><pre><code class="language-julia hljs">B = map(g) do g
    g(x =&gt; x0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×2 Matrix{Float64}:
 0.0        0.0
 0.0        0.0
 0.0        0.0
 0.635714   0.0
 0.0        0.0
 0.0       55.0</code></pre><p>We can see that the equilibrium is not stabilizable. Indeed, if <code>x3</code> is nonzero then <code>x1</code> will grow indefinitely while we have no control over either <code>x1</code> nor <code>x3</code>. Let&#39;s find a Lyapunov function for the rest of the states and compute a linear state feedback for these.</p><pre><code class="language-julia hljs">J = setdiff(1:n_x, [1, 3])
nJ = length(J)
nD = nJ + n_u
E = sparse(1:nJ, 1:nJ, ones(nJ), nJ, nD)
AJ = A[J, J]
BJ = B[J, :]
C = [AJ BJ]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×6 Matrix{Float64}:
 0.0  1.0    0.0    0.0  0.0        0.0
 0.0  0.0    0.0    0.0  0.635714   0.0
 0.0  0.0    0.0    1.0  0.0        0.0
 0.0  0.0  -70.0  -17.0  0.0       55.0</code></pre><p>We know solve [LJ21, (13)]</p><pre><code class="language-julia hljs">using LinearAlgebra
import SCS
solver = optimizer_with_attributes(SCS.Optimizer, MOI.Silent() =&gt; true)
model = Model(solver)
@variable(model, Q[1:nD, 1:nD] in PSDCone())
cref = @constraint(model, Symmetric(-C * Q * E&#39; - E * Q * C&#39;) in PSDCone())
rectangle_J = rectangle[[J; nJ .+ (1:n_u)]]
@constraint(model, rect_ref[i in 1:nD], Q[i, i] &lt;= rectangle[i])
@variable(model, volume)
q = [Q[i, j] for j in 1:nD for i in 1:j]
@constraint(model, [volume; q] in MOI.RootDetConeTriangle(nD))
@objective(model, Max, volume)
optimize!(model)
solution_summary(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">* Solver : SCS

* Status
  Result count       : 1
  Termination status : OPTIMAL
  Message from the solver:
  &quot;solved&quot;

* Candidate solution (result #1)
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Objective value    : 6.24704e-01
  Dual objective value : 6.24693e-01

* Work counters
  Solve time (sec)   : 6.12214e-02
</code></pre><p>We now have the control-Lyapunov function <code>V(x, u) = [x, u]&#39; inv(Q) [x, u]</code>. In other words, The 1-sublevel set of <code>V(x, u)</code> is an invariant subset of <code>rectangle</code> with any state-feedback <code>κ(x)</code> such that <code>V(x, κ(x)) ≤ 1</code> for any <code>x</code> such that <code>min_u V(x, u) ≤ 1</code>. Such candidate <code>κ(x)</code> can therefore be chosen as <code>argmin_u V(x, u)</code>. Let <code>inv(Q) = U&#39; * U</code> where <code>U = [Ux Uu]</code>. We have <code>V(x, u) = ||Ux * x + Uu * u||_2</code>. <code>κ(x)</code> is therefore the least-square solution of <code>Uu * κ(x) = -Ux * x</code>. This we find the linear state-feedback <code>κ(x) = K * x</code> where <code>K = -Uu \ Ux</code>.</p><pre><code class="language-julia hljs">P = inv(Symmetric(value.(Q)))
using LinearAlgebra
F = cholesky(P)
K = -F.U[:, (nJ + 1):(nD)] \ F.U[:, 1:nJ] # That gives the following state feedback in polynomial form:

k = K * x[J]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{DynamicPolynomials.Polynomial{true, Float64}}:
 -0.19622653627237438x₂ - 0.39287266922367087x₄ - 3.930388471170766e-16x₅ - 2.5763934158713317e-16x₆
 2.6828640723569464e-15x₂ - 6.523042058279634e-15x₄ + 0.9534429382637486x₅ - 0.11396000421436397x₆</code></pre><p>We now have two equivalent ways to obtain the Lyapunov function. Because <code>{V(x) ≤ 1} = {min_u V(x, u) ≤ 1}</code>, see the left-hand side as the projection of the ellipsoid on <code>x, u</code>. As the projection on the polar becomes simply cutting with the hyperplane <code>u = 0</code>, the polar of the projection is simply <code>Q[1:6, 1:6]</code> ! So</p><pre><code class="language-julia hljs">Px = inv(Symmetric(value.(Q[1:nJ, 1:nJ])))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:
 0.661753      0.441601      2.86668e-15   2.29212e-15
 0.441601      2.65257      -5.85708e-15  -1.691e-15
 2.86668e-15  -5.85708e-15   1.69023       0.449148
 2.29212e-15  -1.691e-15     0.449148      1.11935</code></pre><p>An alternative way is to use our linear state feedback. We know that <code>min_u V(x, u) = V(x, Kx)</code> so</p><pre><code class="language-julia hljs">Px = [I; K]&#39; * P * [I; K]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 Matrix{Float64}:
 0.661753      0.441601      2.86668e-15   2.29212e-15
 0.441601      2.65257      -5.85708e-15  -1.691e-15
 2.86668e-15  -5.85708e-15   1.69023       0.449148
 2.29212e-15  -1.691e-15     0.449148      1.11935</code></pre><p>We can double check that this matrix is negative definite:</p><pre><code class="language-julia hljs">eigen(Symmetric(Px * (AJ + BJ * K) + (AJ + BJ * K)&#39; * Px)).values</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 -66.96611787243293
  -0.5519161080356569
  -4.058120947211065e-5
  -1.1635183326520363e-5</code></pre><p>Let&#39;s now find a valid Lyapunov function for the nonlinear system using that linear state feedback. That corresponds to the V-step of [YAP21, Algorithm 1]:</p><pre><code class="language-julia hljs">function _create(model, d, P)
    if d isa Int
        return @variable(model, variable_type = P(monomials(x, 0:d)))
        #return @variable(model, variable_type = P(monomials([t; x], 0:d)))
    else
        return d
    end
end
function base_model(solver, V, k, s3, γ)
    model = SOSModel(solver)
    V = _create(model, V, Poly)
    k = _create.(model, k, Poly)
    s3 = _create(model, s3, SOSPoly)
    ∂ = differentiate # Let&#39;s use a fancy shortcut
    @constraint(model, ∂(V, x) ⋅ (f + g * k) &lt;= s3 * (V - γ)) # [YAP21, (E.2)]
    for r in inequalities(X)
        @constraint(model, V &gt;= γ, domain = @set(r &gt;= 0)) # [YAP21, (E.3)]
    end
    return model, V, k, s3
end

_degree(d::Int) = d
_degree(V) = maxdegree(V)

function V_step(solver, V0, γ, k, s3)
    model, V, k, s3 = base_model(solver, _degree(V0), k, s3, γ)
    if !(V0 isa Int)
        @constraint(model, V &gt;= γ, domain = @set(V0 &gt;= γ)) # [YAP21, (E.6)]
    end
    optimize!(model)
    return model, value(V)
end

γ = 1.0
s3 = 1.0
model, V = V_step(solver, 2, γ, k, s3)
solution_summary(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">* Solver : SCS

* Status
  Result count       : 1
  Termination status : OPTIMAL
  Message from the solver:
  &quot;solved&quot;

* Candidate solution (result #1)
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Objective value    : 0.00000e+00
  Dual objective value : -7.48602e-12

* Work counters
  Solve time (sec)   : 6.67364e-03
</code></pre><p>The Lyapunov obtained is as follows</p><pre><code class="language-julia hljs">V</code></pre><p class="math-container">\[ 3.270918395732398e-8x_{1}^{2} + 3.167809298034239e-23x_{1}x_{2} - 2.530765421021385e-12x_{1}x_{3} - 1.6957568763743917e-24x_{1}x_{4} - 4.046968102637713e-12x_{1}x_{5} + 7.155764089773019e-13x_{1}x_{6} + 1.3704656436223044e-7x_{2}^{2} - 1.700600017936993e-23x_{2}x_{3} - 1.745266763178922e-7x_{2}x_{4} - 6.349598762228351e-22x_{2}x_{5} + 3.751457724049311e-22x_{2}x_{6} + 6.917050716923042e-12x_{3}^{2} + 9.069404342588527e-25x_{3}x_{4} + 1.4704199201121313e-13x_{3}x_{5} - 2.3070604887078734e-15x_{3}x_{6} + 1.5612394153649966e-7x_{4}^{2} + 3.8838925942527625e-21x_{4}x_{5} + 2.0809806260551552e-22x_{4}x_{6} + 3.631738895961291e-7x_{5}^{2} - 1.2963928636526255e-9x_{5}x_{6} + 7.072583336286186e-8x_{6}^{2} - 2.906254993885284e-21x_{1} + 5.081950998123909e-7x_{2} - 8.725723805070821e-22x_{3} - 4.1379474225663187e-7x_{4} - 1.2636023067916625e-20x_{5} - 1.9387032398637226e-21x_{6} + 1.0000068335029546 \]</p><p>We now try to find a state feedback that would improve γ</p><pre><code class="language-julia hljs">using MutableArithmetics
function γ_step(solver, V, γ_min, k_best, s3_best, degree_k, degree_s3, γ_tol, max_iters)
    γ0_min = γ_min
    γ_max = Inf
    num_iters = 0
    while γ_max - γ_min &gt; γ_tol &amp;&amp; num_iters &lt; max_iters
        if isfinite(γ_max)
            γ = (γ_min + γ_max) / 2
        else
            γ = γ0_min + (γ_min - γ0_min + 1) * 2
        end
        model, V, k, s3 = base_model(solver, V, degree_k, degree_s3, γ)
        num_iters += 1
        @info(&quot;Iteration $num_iters/$max_iters : solving...&quot;)
        optimize!(model)
        if primal_status(model) == MOI.FEASIBLE_POINT
            γ_min = γ
            k_best = value.(k)
            s3_best = value(s3)
        elseif dual_status(model) == MOI.INFEASIBILITY_CERTIFICATE
            γ_max = γ
        else
            @warn(&quot;Giving up $(raw_status(model)), $(termination_status(model)), $(primal_status(model)), $(dual_status(model))&quot;)
            break
        end
        @info(&quot;Solved in $(solve_time(model)) : γ ∈ ]$γ_min, $γ_max]&quot;)
    end
    if !isfinite(γ_max)
        error(&quot;Cannot find any infeasible γ&quot;)
    end
    return γ_min, k_best, s3_best
end

γ, k, s3 = γ_step(solver, V, γ, k, s3, [2, 2], 2, 1e-3, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.0, DynamicPolynomials.Polynomial{true, Float64}[-0.19622653627237438x₂ - 0.39287266922367087x₄ - 3.930388471170766e-16x₅ - 2.5763934158713317e-16x₆, 2.6828640723569464e-15x₂ - 6.523042058279634e-15x₄ + 0.9534429382637486x₅ - 0.11396000421436397x₆], 1.0)</code></pre><p>We now try to find a new Lyapunov V:</p><pre><code class="language-julia hljs">model, V = V_step(solver, V, γ, k, s3)
solution_summary(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">* Solver : SCS

* Status
  Result count       : 1
  Termination status : OPTIMAL
  Message from the solver:
  &quot;solved&quot;

* Candidate solution (result #1)
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Objective value    : 0.00000e+00
  Dual objective value : -7.83079e-12

* Work counters
  Solve time (sec)   : 7.27932e-03
</code></pre><p>The Lyapunov obtained is as follows</p><pre><code class="language-julia hljs">V</code></pre><p class="math-container">\[ 2.6887299233504928e-8x_{1}^{2} + 2.9872456866778983e-22x_{1}x_{2} - 2.1001715283002107e-12x_{1}x_{3} - 1.0564783856845026e-23x_{1}x_{4} - 4.1701741482069905e-12x_{1}x_{5} + 6.081130476278392e-13x_{1}x_{6} + 1.3292427676820004e-7x_{2}^{2} - 1.2455396604481166e-24x_{2}x_{3} - 1.652986627998994e-7x_{2}x_{4} + 9.704285178591127e-22x_{2}x_{5} + 3.110818506251064e-22x_{2}x_{6} + 5.689477455633206e-12x_{3}^{2} + 4.0087452607583566e-24x_{3}x_{4} - 3.7082957182125265e-13x_{3}x_{5} + 1.936766477769727e-15x_{3}x_{6} + 1.474520495638035e-7x_{4}^{2} + 2.105424731073417e-21x_{4}x_{5} + 3.309792931490456e-22x_{4}x_{6} + 3.252095639402081e-7x_{5}^{2} - 8.895436954412837e-10x_{5}x_{6} + 6.573719564305073e-8x_{6}^{2} - 1.9316086180918378e-21x_{1} + 4.7073526459043376e-7x_{2} - 3.422343936884572e-21x_{3} - 3.924799482096176e-7x_{4} - 5.7908724195359595e-21x_{5} - 1.6851565478676564e-21x_{6} + 1.000006466375888 \]</p><p>We now try to improve γ again</p><pre><code class="language-julia hljs">γ, k, s3 = γ_step(solver, V, γ, k, s3, [2, 2], 2, 1e-3, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.0, DynamicPolynomials.Polynomial{true, Float64}[-0.19622653627237438x₂ - 0.39287266922367087x₄ - 3.930388471170766e-16x₅ - 2.5763934158713317e-16x₆, 2.6828640723569464e-15x₂ - 6.523042058279634e-15x₄ + 0.9534429382637486x₅ - 0.11396000421436397x₆], 1.0)</code></pre><p>We now try to find a new Lyapunov V:</p><pre><code class="language-julia hljs">model, V = V_step(solver, V, γ, k, s3)
solution_summary(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">* Solver : SCS

* Status
  Result count       : 1
  Termination status : OPTIMAL
  Message from the solver:
  &quot;solved&quot;

* Candidate solution (result #1)
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Objective value    : 0.00000e+00
  Dual objective value : -7.83083e-12

* Work counters
  Solve time (sec)   : 7.22054e-03
</code></pre><p>The Lyapunov obtained is as follows</p><pre><code class="language-julia hljs">V</code></pre><p class="math-container">\[ 2.6887299283227056e-8x_{1}^{2} + 2.8762797147229776e-22x_{1}x_{2} - 2.100171534793294e-12x_{1}x_{3} + 7.476442203909692e-25x_{1}x_{4} - 4.170174149078067e-12x_{1}x_{5} + 6.081130486979986e-13x_{1}x_{6} + 1.3292427680563458e-7x_{2}^{2} + 1.9358083615283524e-23x_{2}x_{3} - 1.652986627604508e-7x_{2}x_{4} + 7.647947358637265e-22x_{2}x_{5} + 3.873503353002841e-22x_{2}x_{6} + 5.689477467238331e-12x_{3}^{2} - 9.861014506118508e-25x_{3}x_{4} - 3.7082956913559794e-13x_{3}x_{5} + 1.9367664554255644e-15x_{3}x_{6} + 1.474520495340144e-7x_{4}^{2} + 2.7897772730640074e-21x_{4}x_{5} + 2.1266127707066577e-22x_{4}x_{6} + 3.252095640491712e-7x_{5}^{2} - 8.895436795628335e-10x_{5}x_{6} + 6.573719564113916e-8x_{6}^{2} + 6.0072488023391475e-22x_{1} + 4.7073526494024047e-7x_{2} + 1.0450303630378034e-21x_{3} - 3.9247994881491304e-7x_{4} - 8.33211884396278e-21x_{5} - 1.834370496240584e-21x_{6} + 1.0000064663758899 \]</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lyapunov_function_search/">« Lyapunov Function Search</a><a class="docs-footer-nextpage" href="../stabilization_of_nonlinear_systems/">Stabilization of nonlinear systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 22 February 2023 13:55">Wednesday 22 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
