######################
# Ideal certificates #
######################

abstract type AbstractIdealCertificate <: AbstractCertificate end

abstract type SimpleIdealCertificate{CT,BT} <: AbstractIdealCertificate end
reduced_polynomial(::SimpleIdealCertificate, poly, domain) = poly

cone(certificate::SimpleIdealCertificate) = certificate.cone
function SumOfSquares.matrix_cone_type(
    ::Type{<:SimpleIdealCertificate{CT}},
) where {CT}
    return SumOfSquares.matrix_cone_type(CT)
end

# TODO return something else when `PolyJuMP` support other bases.
zero_basis(::SimpleIdealCertificate) = MB.MonomialBasis
function zero_basis_type(::Type{<:SimpleIdealCertificate{CT,BT}}) where {CT,BT}
    return MB.MonomialBasis
end

"""
    struct MaxDegree{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: SimpleIdealCertificate{CT, BT}
        cone::CT
        basis::Type{BT}
        maxdegree::Int
    end

The `MaxDegree` certificate ensures the nonnegativity of `p(x)` for all `x` such that
`h_i(x) = 0` by exhibiting a Sum-of-Squares polynomials `σ(x)`
such that `p(x) - σ(x)` is guaranteed to be zero for all `x`
such that `h_i(x) = 0`.
The polynomial `σ(x)` is search over `cone` with a basis of type `basis` such that
the degree of `σ(x)` does not exceed `maxdegree`.
"""
struct MaxDegree{CT<:SumOfSquares.SOSLikeCone,BT<:MB.AbstractPolynomialBasis} <:
       SimpleIdealCertificate{CT,BT}
    cone::CT
    basis::Type{BT}
    maxdegree::Int
end
function gram_basis(certificate::MaxDegree, poly)
    return maxdegree_gram_basis(
        certificate.basis,
        MP.variables(poly),
        certificate.maxdegree,
    )
end
function gram_basis_type(::Type{MaxDegree{CT,BT}}) where {CT,BT}
    return BT
end

"""
    struct FixedBasis{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: SimpleIdealCertificate{CT, BT}
        cone::CT
        basis::BT
    end

The `FixedBasis` certificate ensures the nonnegativity of `p(x)` for all `x` such that
`h_i(x) = 0` by exhibiting a Sum-of-Squares polynomials `σ(x)`
such that `p(x) - σ(x)` is guaranteed to be zero for all `x`
such that `h_i(x) = 0`.
The polynomial `σ(x)` is search over `cone` with basis `basis`.
"""
struct FixedBasis{
    CT<:SumOfSquares.SOSLikeCone,
    BT<:MB.AbstractPolynomialBasis,
} <: SimpleIdealCertificate{CT,BT}
    cone::CT
    basis::BT
end
function gram_basis(certificate::FixedBasis, poly)
    return certificate.basis
end
function gram_basis_type(::Type{FixedBasis{CT,BT}}) where {CT,BT}
    return BT
end

"""
    struct Newton{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis, NPT <: Tuple} <: SimpleIdealCertificate{CT, BT}
        cone::CT
        basis::Type{BT}
        variable_groups::NPT
    end

The `Newton` certificate ensures the nonnegativity of `p(x)` for all `x` such that
`h_i(x) = 0` by exhibiting a Sum-of-Squares polynomials `σ(x)`
such that `p(x) - σ(x)` is guaranteed to be zero for all `x`
such that `h_i(x) = 0`.
The polynomial `σ(x)` is search over `cone` with a basis of type `basis`
chosen using the multipartite Newton polytope with parts `variable_groups`.
If `variable_groups = tuple()` then it falls back to the classical Newton polytope
with all variables in the same part.
"""
struct Newton{
    CT<:SumOfSquares.SOSLikeCone,
    BT<:MB.AbstractPolynomialBasis,
    NPT<:Tuple,
} <: SimpleIdealCertificate{CT,BT}
    cone::CT
    basis::Type{BT}
    variable_groups::NPT
end
function gram_basis(certificate::Newton{CT,B}, poly) where {CT,B}
    return MB.basis_covering_monomials(
        B,
        monomials_half_newton_polytope(
            MP.monomials(poly),
            certificate.variable_groups,
        ),
    )
end
function gram_basis_type(::Type{<:Newton{CT,BT}}) where {CT,BT}
    return BT
end

"""
    struct Remainder{GCT<:AbstractIdealCertificate} <: AbstractIdealCertificate
        gram_certificate::GCT
    end

The `Remainder` certificate ensures the nonnegativity of `p(x)` for all `x` such that
`h_i(x) = 0` by guaranteeing the remainder of `p(x)` modulo the ideal generated by
`⟨h_i⟩` to be nonnegative for all `x` such that `h_i(x) = 0` using the certificate
`gram_certificate`.
For instance, if `gram_certificate` is [`SumOfSquares.Certificate.Newton`](@ref),
then the certificate `Remainder(gram_certificate)` will take the remainder before
computing the Newton polytope hence might generate a much smaller Newton polytope
hence a smaller basis and smaller semidefinite program.
However, this then corresponds to a lower degree of the hierarchy which might
be insufficient to find a certificate.
"""
struct Remainder{GCT<:AbstractIdealCertificate} <: AbstractIdealCertificate
    gram_certificate::GCT
end

function reduced_polynomial(::Remainder, poly, domain)
    return convert(typeof(poly), rem(poly, ideal(domain)))
end

function gram_basis(certificate::Remainder, poly)
    return gram_basis(certificate.gram_certificate, poly)
end
function gram_basis_type(::Type{Remainder{GCT}}) where {GCT}
    return gram_basis_type(GCT)
end

cone(certificate::Remainder) = cone(certificate.gram_certificate)
function SumOfSquares.matrix_cone_type(::Type{Remainder{GCT}}) where {GCT}
    return SumOfSquares.matrix_cone_type(GCT)
end
zero_basis(certificate::Remainder) = zero_basis(certificate.gram_certificate)
zero_basis_type(::Type{Remainder{GCT}}) where {GCT} = zero_basis_type(GCT)
