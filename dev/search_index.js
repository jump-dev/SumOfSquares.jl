var documenterSearchIndex = {"docs":
[{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/SOS decomposition.jl\"","category":"page"},{"location":"generated/SOS decomposition/#A-trivial-SOS-decomposition-example","page":"SOS decomposition","title":"A trivial SOS decomposition example","text":"","category":"section"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"(Image: ) (Image: ) Contributed by: votroto Adapted from: Examples 3.25 of [BPT12]","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"using DynamicPolynomials\nusing SumOfSquares\nimport CSDP","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"The polynomial p = x^2 - x*y^2 + y^4 + 1 is SOS. We can, for example, decompose it as p = 3/4*(x - y^2)^2 + 1/4*(x + y)^2 + 1, which clearly proves that p is SOS, and there are infinitely many other ways to decompose p into sums of squares.","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"We can use SumOfSquares.jl to find such decompositions.","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"First, setup the polynomial of interest.","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"@polyvar x y\np = x^2 - x*y^2 + y^4 + 1","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"Secondly, constrain the polynomial to be nonnegative. SumOfSquares.jl transparently reinterprets polyonmial nonnegativity as the appropriate SOS certificate for polynomials nonnegative on semialgebraic sets.","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"model = SOSModel(CSDP.Optimizer)\n@constraint(model, cref, p >= 0)","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"Thirdly, optimize the feasibility problem!","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"optimize!(model)","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"Lastly, recover a SOS decomposition. In general, SOS decompositions are not unique!","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"sos_dec = sos_decomposition(cref, 1e-4)","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"Converting, rounding, and simplifying - Huzza, Back where we began!","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"polynomial(sos_dec, Float32)","category":"page"},{"location":"generated/SOS decomposition/#A-deeper-explanation-and-the-unexplained-1e-4-parameter","page":"SOS decomposition","title":"A deeper explanation and the unexplained 1e-4 parameter","text":"","category":"section"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"p = x^2 - x*y^2 + y^4 + 1 can be represented in terms of its Gram matrix as","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"gram = gram_matrix(cref)","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"gram.basis.monomials' * gram.Q * gram.basis.monomials","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"where the matrix gram.Q is positive semidefinite, because p is SOS. If we could only get the decomposition gram.Q = V' * V, the SOS decomposition would simply be ||V * monomials||^2.","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"Unfortunately, we can not use Cholesky decomposition, since gram Q is only semidefinite, not definite. Hence, SumOfSquares.jl uses SVD decomposition instead and discards small singular values (in our case 1e-4).","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"","category":"page"},{"location":"generated/SOS decomposition/","page":"SOS decomposition","title":"SOS decomposition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Stabilization of nonlinear systems.jl\"","category":"page"},{"location":"generated/Stabilization of nonlinear systems/#Stabilization-of-nonlinear-systems","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"","category":"section"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"(Image: ) (Image: ) Adapted from: Examples 1, 2 and 3 of [PPA04]","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"[PPA04] Prajna, Stephen, Pablo A. Parrilo, and Anders Rantzer. Nonlinear control synthesis by convex optimization. IEEE Transactions on Automatic Control 49.2 (2004): 310-314.","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"using DynamicPolynomials\n@polyvar x[1:2]\n\nusing SumOfSquares\nusing CSDP\nusing LinearAlgebra # for ⋅\nusing MultivariatePolynomials\ndivergence(f) = sum(differentiate.(f, x))\nfunction controller(f, g, b, α, degs)\n    solver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\n    model = SOSModel(solver)\n    a = 1\n    monos = monomials(x, degs)\n    N = length(monos) + 1\n    @variable(model, c[1:N] in MOI.NormOneCone(N))\n    c_poly = polynomial(c[2:end], monos)\n    fagc = f * a + g * c_poly\n    @constraint(model, b * divergence(fagc) - α * differentiate(b, x) ⋅ fagc in SOSCone())\n    @objective(model, Min, c[1])\n    optimize!(model)\n    if termination_status(model) != MOI.OPTIMAL\n        @warn(\"Termination status $(termination_status(model)): $(raw_status(model))\")\n    end\n    u = value(c_poly) / value(a)\n    return MultivariatePolynomials.mapcoefficientsnz(coef -> abs(coef) < 1e-6 ? 0.0 : coef, u)\nend\n\nimport DifferentialEquations, Plots\nfunction phase_plot(f, quiver_scaling, Δt, X0, solver = DifferentialEquations.Tsit5())\n    ∇(vx, vy) = [fi(x[1] => vx, x[2] => vy) for fi in f]\n    ∇pt(v, p, t) = ∇(v[1], v[2])\n    function traj(v0)\n        tspan = (0.0, Δt)\n        prob = DifferentialEquations.ODEProblem(∇pt, v0, tspan)\n        return DifferentialEquations.solve(prob, solver, reltol=1e-8, abstol=1e-8)\n    end\n    ticks = -5:0.5:5\n    X = repeat(ticks, 1, length(ticks))\n    Y = X'\n    Plots.quiver(X, Y, quiver = (x, y) -> ∇(x, y) / quiver_scaling, linewidth=0.5)\n    for x0 in X0\n        Plots.plot!(traj(x0), vars=(1, 2), label = nothing)\n    end\n    Plots.plot!(xlims = (-5, 5), ylims = (-5, 5))\nend","category":"page"},{"location":"generated/Stabilization of nonlinear systems/#Example-1","page":"Stabilization of nonlinear systems","title":"Example 1","text":"","category":"section"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"g = [0, 1]\nf = [x[2] - x[1]^3 + x[1]^2, 0]\nb = 3x[1]^2 + 2x[1]*x[2] + 2x[2]^2\nu = controller(f, g, b, 4, 0:3)","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"We find the controller above which gives the following phase plot.","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"phase_plot(f + g * u, 200, 10.0, [[x1, x2] for x1 in -5:5:5, x2 in -5:5:5 if x1 != 0 || x2 != 0])","category":"page"},{"location":"generated/Stabilization of nonlinear systems/#Example-2","page":"Stabilization of nonlinear systems","title":"Example 2","text":"","category":"section"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"g = [0, 1]\nf = [2x[1]^3 + x[1]^2*x[2] - 6x[1]*x[2]^2 + 5x[2]^3, 0]\nb = x[1]^2 + x[2]^2\nu = controller(f, g, b, 2.5, 0:3)","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"We find the controller above which gives the following phase plot.","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"phase_plot(f + g * u, 2000, 5.0, [[-1.0, -5.0], [1.0, 5.0]])","category":"page"},{"location":"generated/Stabilization of nonlinear systems/#Example-3","page":"Stabilization of nonlinear systems","title":"Example 3","text":"","category":"section"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"g = [0, x[2]]\nf = [-6x[1]*x[2]^2 - x[1]^2*x[2] + 2x[2]^3, 0]\nb = x[1]^2 + x[2]^2\nu = controller(f, g, b, 3, 0:2)","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"We find the controller above which gives the following phase plot.","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"X0 = [Float64[x1, x2] for x1 in -5:5:5, x2 in -5:5:5 if x2 != 0]\nε = 1e-4 # We separate the starting point slightly from the hyperplane `x2 = 0` which is invariant.\npush!(X0, [-4,  ε])\npush!(X0, [-3, -ε])\npush!(X0, [ 3,  ε])\npush!(X0, [ 4, -ε])\nphase_plot(f + g * u, 2000, 10.0, X0)","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"","category":"page"},{"location":"generated/Stabilization of nonlinear systems/","page":"Stabilization of nonlinear systems","title":"Stabilization of nonlinear systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Polynomial Optimization.jl\"","category":"page"},{"location":"generated/Polynomial Optimization/#Polynomial-Optimization","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"","category":"section"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Polynomial Optimization/#Introduction","page":"Polynomial Optimization","title":"Introduction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Consider the polynomial optimization problem of minimizing the polynomial x^3 - x^2 + 2xy -y^2 + y^3 over the polyhedron defined by the inequalities x ge 0 y ge 0 and x + y geq 1.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"using DynamicPolynomials\n@polyvar x y\np = x^3 - x^2 + 2x*y -y^2 + y^3\nusing SumOfSquares\nS = @set x >= 0 && y >= 0 && x + y >= 1\np(x=>1, y=>0), p(x=>1//2, y=>1//2), p(x=>0, y=>1)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The optimal solutions are (x y) = (1 0) and (x y) = (0 1) with objective value 0 but Ipopt only finds the local minimum (12 12) with objective value 14.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"import Ipopt\nmodel = Model(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))\n@variable(model, a >= 0)\n@variable(model, b >= 0)\n@constraint(model, a + b >= 1)\n@NLobjective(model, Min, a^3 - a^2 + 2a*b - b^2 + b^3)\noptimize!(model)\n@show termination_status(model)\n@show value(a)\n@show value(b)\n@show objective_value(model)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Note that the problem can be written equivalently as follows using registered functions.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"using Ipopt\nmodel = Model(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))\n@variable(model, a >= 0)\n@variable(model, b >= 0)\n@constraint(model, a + b >= 1)\npeval(a, b) = p(x=>a, y=>b)\nregister(model, :peval, 2, peval, autodiff=true)\n@NLobjective(model, Min, peval(a, b))\noptimize!(model)\n@show termination_status(model)\n@show value(a)\n@show value(b)\n@show objective_value(model)\n\n# Sum-of-Squares approach","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"We will now see how to find the optimal solution using Sum of Squares Programming. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"import CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"A Sum-of-Squares certificate that p ge alpha over the domain S, ensures that alpha is a lower bound to the polynomial optimization problem. The following program searches for the largest upper bound and finds zero.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"model = SOSModel(solver)\n@variable(model, α)\n@objective(model, Max, α)\n@constraint(model, c3, p >= α, domain = S)\noptimize!(model)\n@show termination_status(model)\n@show objective_value(model)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Using the solution (12 12) found by Ipopt of objective value 14 and this certificate of lower bound 0 we know that the optimal objective value is in the interval 0 14 but we still do not know what it is (if we consider that we did not try the solutions (1 0) and (0 1) as done in the introduction). If the dual of the constraint c3 was atomic, its atoms would have given optimal solutions of objective value 0 but that is not the case.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν3 = moment_matrix(c3)\nextractatoms(ν3, 1e-3) # Returns nothing as the dual is not atomic","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Fortunately, there is a hierarchy of programs with increasingly better bounds that can be solved until we get one with atom dual variables. This comes from the way the Sum-of-Squares constraint with domain S is formulated. The polynomial p - alpha is guaranteed to be nonnegative over the domain S if there exists Sum-of-Squares polynomials s_0, s_1, s_2, s_3 such that $ p - \\alpha = s0 + s1 x + s2 y + s3 (x + y - 1). $ Indeed, in the domain S, x, y and x + y - 1 are nonnegative so the right-hand side is a sum of squares hence is nonnegative. Once the degrees of s_1, s_2 and s_3 have been decided, the degree needed for s_0 will be determined but we have a freedom in choosing the degrees of s_1, s_2 and s_3. By default, they are chosen so that the degrees of s_1 x, s_2 y and s_3 (x + y - 1) match those of p - alpha but this can be overwritten using the maxdegree keyword argument.","category":"page"},{"location":"generated/Polynomial Optimization/#The-maxdegree-keyword-argument","page":"Polynomial Optimization","title":"The maxdegree keyword argument","text":"","category":"section"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The maximum total degree (i.e. maximum sum of the exponents of x and y) of the monomials of p is 3 so the constraint in the program above is equivalent to @constraint(model, p >= α, domain = S, maxdegree = 3). That is, since x, y and x + y - 1 have total degree 1, the sum of squares polynomials s_1, s_2 and s_3 have been chosen with maximum total degree 2. Since these polynomials are sums of squares, their degree must be even so the next maximum total degree to try is 4. For this reason, the keywords maxdegree = 4 and maxdegree = 5 have the same effect in this example. In general, if the polynomials in the domain are not all odd or all even, each value of maxdegree has different effect in the choice of the maximum total degree of s_i.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"model = SOSModel(solver)\n@variable(model, α)\n@objective(model, Max, α)\n@constraint(model, c5, p >= α, domain = S, maxdegree = 5)\noptimize!(model)\n@show termination_status(model)\n@show objective_value(model)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This time, the dual variable is atomic as it is the moments of the measure 05 delta(x-1 y) + 05 delta(x y-1) where delta(x y) is the dirac measure centered at (0 0). Therefore the program provides both a certificate that 0 is a lower bound and a certificate that it is also an upper bound since it is attained at the global minimizers (1 0) and (0 1).","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν5 = moment_matrix(c5)\nextractatoms(ν5, 1e-3)","category":"page"},{"location":"generated/Polynomial Optimization/#A-deeper-look-into-atom-extraction","page":"Polynomial Optimization","title":"A deeper look into atom extraction","text":"","category":"section"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The extractatoms function requires a ranktol argument that we have set to 1e-3 in the preceding section. This argument is used to transform the dual variable into a system of polynomials equations whose solutions give the atoms. This transformation uses the SVD decomposition of the moment matrix and discards the equations corresponding to a singular value lower than ranktol. When this system of equation has an infinite number of solutions, extractatoms concludes that the measure is not atomic. For instance, with maxdegree = 3, we obtain the system x + y = 1 which contains a whole line of solution. This explains extractatoms returned nothing.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν3 = moment_matrix(c3)\nSumOfSquares.MultivariateMoments.computesupport!(ν3, 1e-3)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"With maxdegree = 5, we obtain the system \\begin{align}   x + y & = 1\\\n  y^2 & = y\\\n  xy & = 0\\\n  x^2 + y & = 1 \\end{align}","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"ν5 = moment_matrix(c5)\nSumOfSquares.MultivariateMoments.computesupport!(ν5, 1e-3)","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This system can be reduced to the equivalent system \\begin{align}   x + y & = 1\\\n  y^2 & = y \\end{align} which has the solutions (0 1) and (1 0).","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"SemialgebraicSets.computegröbnerbasis!(ideal(ν5.support))\nν5.support","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"The function extractatoms then reuse the matrix of moments to find the weights 12, 12 corresponding to the diracs centered respectively at (0 1) and (1 0). This details the how the function obtained the result 05 delta(x-1 y) + 05 delta(x y-1) given in the previous section.","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"","category":"page"},{"location":"generated/Polynomial Optimization/","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Noncommutative variables.jl\"","category":"page"},{"location":"generated/Noncommutative variables/#Noncommutative-variables","page":"Noncommutative variables","title":"Noncommutative variables","text":"","category":"section"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"(Image: ) (Image: ) Adapted from: Examples 2.11 and 2.2 of [BKP16]","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"[BKP16] Sabine Burgdorf, Igor Klep, and Janez Povh. Optimization of polynomials in non-commuting variables. Berlin: Springer, 2016.","category":"page"},{"location":"generated/Noncommutative variables/#Example-2.11","page":"Noncommutative variables","title":"Example 2.11","text":"","category":"section"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We consider the Example 2.11 of [BKP16] in which the polynomial with noncommutative variables (x * y + x^2)^2 = x^4 + x^3y + xyx^2 + xyxy is tested to be sum-of-squares.","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"using DynamicPolynomials\n@ncpolyvar x y\np = (x * y + x^2)^2","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"using SumOfSquares\nimport CSDP\noptimizer_constructor = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = Model(optimizer_constructor)\ncon_ref = @constraint(model, p in SOSCone())\n\noptimize!(model)","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We see that both the monomials xy and yx are considered separately, this is a difference with the commutative version.","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"certificate_basis(con_ref)","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We see that the solution correctly uses the monomial xy instead of yx. We also identify that only the monomials x^2 and xy would be needed. This would be dectected by the Newton chip method of [Section 2.3, BKP16].","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"gram_matrix(con_ref).Q","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"When asking for the SOS decomposition, the numerically small entries makes the solution less readable.","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"sos_decomposition(con_ref) #!src","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"They are however easily discarded by using a nonzero tolerance:","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"sos_decomposition(con_ref, 1e-6)       #!src","category":"page"},{"location":"generated/Noncommutative variables/#Example-2.2","page":"Noncommutative variables","title":"Example 2.2","text":"","category":"section"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"We consider now the Example 2.2 of [BKP16] in which the polynomial with noncommutative variables (x + x^10y^20x^10)^2 is tested to be sum-of-squares.","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"using DynamicPolynomials\n@ncpolyvar x y\nn = 10\np = (x + x^n * y^(2n) * x^n)^2\n\nusing SumOfSquares\nmodel = Model(optimizer_constructor)\ncon_ref = @constraint(model, p in SOSCone())\n\noptimize!(model)","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"Only two monomials were considered for the basis of the gram matrix thanks to the Augmented Newton chip method detailed in [Section 2.4, BKP16].","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"certificate_basis(con_ref)\n\ngram_matrix(con_ref).Q\n\nsos_decomposition(con_ref, 1e-6)","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"","category":"page"},{"location":"generated/Noncommutative variables/","page":"Noncommutative variables","title":"Noncommutative variables","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Even reduction.jl\"","category":"page"},{"location":"generated/Even reduction/#Even-reduction","page":"Even reduction","title":"Even reduction","text":"","category":"section"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"using Pkg\npkg\"add https://github.com/kalmarek/SymbolicWedderburn.jl#bl/nonperm\"\n\nimport MutableArithmetics\nconst MA = MutableArithmetics\nusing MultivariatePolynomials\nconst MP = MultivariatePolynomials\nusing MultivariateBases\nconst MB = MultivariateBases\n\nusing DynamicPolynomials\n@polyvar x","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"We would like to find the minimum value of the polynomial","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"poly = x^4 - 2x^2\n\nusing SymbolicWedderburn\nusing PermutationGroups\nusing Cyclotomics\nusing SumOfSquares","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"This is still a work in progress in SumOfSquares, so we need to define things here that will be moved inside SumOfSquares.jl once SymbolicWedderburn.jl is released:","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"struct ScaledPerm2{T, I} <: AbstractPerm\n    indices::Vector{Pair{I, T}}\nend\nBase.one(p::ScaledPerm2{T}) where {T} = ScaledPerm2([i => one(T) for i in eachindex(p.indices)])\nBase.:(==)(p::ScaledPerm2, q::ScaledPerm2) = p.indices == q.indices\nBase.hash(p::ScaledPerm2, u::UInt64) = hash(p.indices, u)\nSymbolicWedderburn.degree(p::ScaledPerm2) = length(p.indices)\nBase.:^(i::Integer, p::ScaledPerm2) = p.indices[i]\nfunction SymbolicWedderburn.add_inverse_permutation!(result, val, i::Int, j::Pair)\n    result[i, j.first] += val / j.second\nend\n\nfunction permutation(ehom::SymbolicWedderburn.ExtensionHomomorphism{T}, els::Vector{T}) where {T}\n    return Perm([ehom[el] for el in els])\nend\nfunction permutation(ehom::SymbolicWedderburn.ExtensionHomomorphism{<:AbstractMonomial}, terms::Vector{<:AbstractTerm})\n    return ScaledPerm2([ehom[monomial(term)] => coefficient(term) for term in terms])\nend\nfunction (ehom::SymbolicWedderburn.ExtensionHomomorphism)(action)\n    return permutation(ehom, [f^action for f in ehom.features])\nend\n\nfunction SymbolicWedderburn.ExtensionHomomorphism(basis::MB.MonomialBasis)\n    monos = collect(basis.monomials)\n    mono_to_index = Dict(monos[i] => i for i in eachindex(monos))\n    return SymbolicWedderburn.ExtensionHomomorphism(monos, mono_to_index)\nend\n\nfunction MP.polynomialtype(::Type{<:MB.AbstractPolynomialVectorBasis{PT}}, T::Type) where PT\n    C = MP.coefficienttype(PT)\n    U = MA.promote_operation(*, C, T)\n    V = MA.promote_operation(+, U, U)\n    return MP.polynomialtype(PT, V)\nend\n\nstruct SymmetricIdeal{CT, GT} <: Certificate.AbstractIdealCertificate\n    cone::CT\n    group::GT\nend\nSumOfSquares.matrix_cone_type(::Type{<:SymmetricIdeal{CT}}) where {CT} = SumOfSquares.matrix_cone_type(CT)\nCertificate.get(::Type{<:SymmetricIdeal}, ::SumOfSquares.Certificate.GramBasisType) = Vector{MB.FixedPolynomialBasis}\nCertificate.zero_basis_type(::Type{<:SymmetricIdeal}) = MB.MonomialBasis\nCertificate.zero_basis(::SymmetricIdeal) = MB.MonomialBasis\nCertificate.get(::SymmetricIdeal, ::Certificate.ReducedPolynomial, poly, domain) = poly\nfunction Certificate.get(cert::SymmetricIdeal, ::Certificate.GramBasis, poly)\n    basis = Certificate.maxdegree_gram_basis(MB.MonomialBasis, MP.variables(poly), MP.maxdegree(poly))\n    R = SymbolicWedderburn.symmetry_adapted_basis(Float64, cert.group, basis)\n    return map(R) do Ri\n        FixedPolynomialBasis(convert(Matrix{Float64}, Ri) * basis.monomials)\n    end\nend","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"We define the custom group as follows:","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"struct EvenOddAction <: GroupElem\n    identity::Bool\nend\nPermutationGroups.order(a::EvenOddAction) = a.identity ? 1 : 2\nBase.one(::EvenOddAction) = EvenOddAction(true)\nBase.inv(a::EvenOddAction) = a\nPermutationGroups.mul!(::EvenOddAction, a::EvenOddAction, b::EvenOddAction) = EvenOddAction(xor(a.identity, b.identity))\nfunction Base.:^(mono::AbstractMonomial, a::EvenOddAction)\n    if a.identity || iseven(MP.degree(mono))\n        return 1 * mono\n    else\n        return -1 * mono\n    end\nend\n\nstruct EvenOddSymmetry <: Group\nend\n_orbit(cc) = PermutationGroups.Orbit(cc, Dict(a => nothing for a in cc))\nSymbolicWedderburn.conjugacy_classes_orbit(::EvenOddSymmetry) = [_orbit([EvenOddAction(true)]), _orbit([EvenOddAction(false)])]\n\nG = EvenOddSymmetry()","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"We can exploit the symmetry as follows:","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"import CSDP\nsolver = CSDP.Optimizer\nmodel = Model(solver)\n@variable(model, t)\n@objective(model, Max, t)\ncon_ref = @constraint(model, poly - t in SOSCone(), ideal_certificate = SymmetricIdeal(SOSCone(), G))\noptimize!(model)\n@show value(t)\nvalue(t)","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"We indeed find -1, let's verify that symmetry was exploited:","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"gram_matrix(con_ref)","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"","category":"page"},{"location":"generated/Even reduction/","page":"Even reduction","title":"Even reduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Getting started.jl\"","category":"page"},{"location":"generated/Getting started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO1 (See Section 4.1 of SOSTOOLS User's Manual) and Example 2.4 of [PJ08]","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"P. Parrilo and A. Jadbabaie Approximation of the joint spectral radius using sum of squares. Linear Algebra and its Applications, Elsevier (2008), 428, 2385-2402","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"using DynamicPolynomials\n@polyvar x y\np = 2*x^4 + 2*x^3*y - x^2*y^2 + 5*y^4","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"using SumOfSquares\nimport CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver)\ncon_ref = @constraint(model, p >= 0)\noptimize!(model)\nprimal_status(model)","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"We see above that the solver found a feasible solution. We now inspect this solution:","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"q = gram_matrix(con_ref)","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"We can get the SOS decomposition from the gram matrix as follows:","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"sosdec = SOSDecomposition(q)","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"We now seek for the SOS decomposition of the following polynomial:","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"p = 4*x^4*y^6 + x^2 - x*y^2 + y^2","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"We build the same model as previously with this new polynomial. Here we can use Model instead of SOSModel as we explicitly constrain p to belong to the SOS cone with p in SOSCone().","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"model = Model(solver)\ncon_ref = @constraint(model, p in SOSCone())\noptimize!(model)\nprimal_status(model)","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"We can query the SOS decomposition direction from the constraint reference as follows:","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"sos_decomposition(con_ref)","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"generated/Getting started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sumofsquares/#Sum-of-Squares-Programming","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"This section contains a brief introduction to Sum-of-Squares Programming. For more details, see [BPT12, Las09, Lau09].","category":"page"},{"location":"sumofsquares/#Quadratic-forms-and-Semidefinite-programming","page":"Sum-of-Squares Programming","title":"Quadratic forms and Semidefinite programming","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"The positive semidefiniteness of a n times n real symmetric matrix Q is equivalent to the nonnegativity of the quadratic form p(x) = x^top Q x for all vector x in mathbbR^n. For instance, the polynomial","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"x_1^2 + 2x_1x_2 + 5x_2^2 + 4x_2x_3 + x_3^2 = x^top beginpmatrix1  1  01  5  2 0  2  1endpmatrix x","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"is nonnegative since the matrix of the right-hand side is positive semidefinite. Moreover, a certificate of nonnegativity can be extracted from the Cholesky decomposition of the matrix:","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"(x_1 + x_2)^2 + (2x_2 + x_3)^2 = x^top beginpmatrix1  1  00  2  1endpmatrix^top beginpmatrix1  1  00  2  1endpmatrix x","category":"page"},{"location":"sumofsquares/#Polynomial-nonnegativity-and-Semidefinite-programming","page":"Sum-of-Squares Programming","title":"Polynomial nonnegativity and Semidefinite programming","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"This can be generalized to a polynomial of arbitrary degree. A polynomial p(x) is nonnegative if it can be rewritten as p(x) = X^top Q X where Q is a real symmetric positive semidefinite matrix and X is a vector of monomials.","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"For instance","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"x_1^2 + 2x_1^2x_2 + 5x_1^2x_2^2 + 4x_1x_2^2 + x_2^2 = X^top beginpmatrix1  1  01  5  2 0  2  1endpmatrix X","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"where X = (x_1 x_1x_2 x_2) Similarly to the previous section, the Cholesky factorization of the matrix can be used to extract a sum of squares certificate of nonnegativity for the polynomial:","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"(x_1 + x_1x_2)^2 + (2x_1x_2 + x_2)^2 = X^top beginpmatrix1  1  00  2  1endpmatrix^top beginpmatrix1  1  00  2  1endpmatrix X","category":"page"},{"location":"sumofsquares/#When-is-nonnegativity-equivalent-to-sum-of-squares-?","page":"Sum-of-Squares Programming","title":"When is nonnegativity equivalent to sum of squares ?","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"Determining whether a polynomial is nonnegative is NP-hard. The condition of the previous section was only sufficient, that is, there exists nonnegative polynomials that are not sums of squares. Hilbert showed in 1888 that there are exactly 3 cases for which there is equivalence between the nonnegativity of the polynomials of n variables and degree 2d and the existence of a sum of squares decomposition.","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"n = 1 : Univariate polynomials\n2d = 2 : Quadratic polynomials\nn = 2, 2d = 4 : Bivariate quartics","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"The first explicit example of polynomial that was not a sum of squares was given by Motzkin in 1967:","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"x_1^4x_2^2 + x_1^2x_2^4 + 1 - 3x_1^2x_2^2 geq 0 quad forall x","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"While it is not a sum of squares, it can still be certified to be nonnegative using sum-of-squares programming by identifying it with a rational sum-of-squares decomposition. These facts can be verified numerically using this package as detailed in the motzkin notebook.","category":"page"},{"location":"sumofsquares/#References","page":"Sum-of-Squares Programming","title":"References","text":"","category":"section"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"[Las09] Lasserre, J. B. Moments, positive polynomials and their applications World Scientific, 2009.","category":"page"},{"location":"sumofsquares/","page":"Sum-of-Squares Programming","title":"Sum-of-Squares Programming","text":"[Lau09] Laurent, M. Sums of squares, moment matrices and optimization over polynomials Emerging applications of algebraic geometry, Springer, 2009, 157-270.","category":"page"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/#Equality-constraints-between-polynomials","page":"Constraints","title":"Equality constraints between polynomials","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Equality between polynomials in PolyJuMP uses the same syntax as equality between affine or quadratic expression in JuMP. For instance, creating two quadratic n-variate polynomials p and q that must sum up to one can be done as follows:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> n = 3\n3\n\njulia> using DynamicPolynomials\n\njulia> @polyvar x[1:n]\n(DynamicPolynomials.PolyVar{true}[x₁, x₂, x₃],)\n\njulia> X = monomials(x, 0:2)\n10-element MonomialVector{true}:\n x₁²\n x₁x₂\n x₁x₃\n x₂²\n x₂x₃\n x₃²\n x₁\n x₂\n x₃\n 1\n\njulia> using SumOfSquares\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, p, Poly(X))\n(noname)x₁² + (noname)x₁x₂ + (noname)x₁x₃ + (noname)x₂² + (noname)x₂x₃ + (noname)x₃² + (noname)x₁ + (noname)x₂ + (noname)x₃ + (noname)\n\njulia> @variable(model, q, Poly(X))\n(noname)x₁² + (noname)x₁x₂ + (noname)x₁x₃ + (noname)x₂² + (noname)x₂x₃ + (noname)x₃² + (noname)x₁ + (noname)x₂ + (noname)x₃ + (noname)\n\njulia> @constraint(model, p + q == 1)\n(noname + noname)x₁² + (noname + noname)x₁x₂ + (noname + noname)x₁x₃ + (noname + noname)x₂² + (noname + noname)x₂x₃ + (noname + noname)x₃² + (noname + noname)x₁ + (noname + noname)x₂ + (noname + noname)x₃ + (noname + noname - 1) ∈ PolyJuMP.ZeroPoly()","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Vectorized constraints can also be used as well as vector of constraints, named constraints, ... For instance, if P and Q are two n times n matrices of polynomials, the following constraints the sum of rows and columns to match:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"@constraint(model, con[i=1:n], sum(P[i, :]) == sum(Q[:, i]))","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"and con[i] contains the reference to the constraint between the ith row of P and the ith column of Q.","category":"page"},{"location":"constraints/#Inequality-constraints-between-polynomials","page":"Constraints","title":"Inequality constraints between polynomials","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Polynomials can be constrained to be sum-of-squares with the in syntax. For instance, to constrain a polynomial p to be sum-of-squares, do","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, p in SOSCone())\n(noname)x₁² + (noname)x₁x₂ + (noname)x₁x₃ + (noname)x₂² + (noname)x₂x₃ + (noname)x₃² + (noname)x₁ + (noname)x₂ + (noname)x₃ + (noname) is SOS","category":"page"},{"location":"constraints/#Automatically-interpreting-polynomial-nonnegativity-as-a-sum-of-squares-constraint","page":"Constraints","title":"Automatically interpreting polynomial nonnegativity as a sum-of-squares constraint","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As detailed in When is nonnegativity equivalent to sum of squares ?, the nonnegativity of a polynomial is not equivalent to the existence of a sum-of-squares decomposition. However, if explicitely specified, nonnegativity constraints can be automatically interpreted as sum-of-squares constraints. The simplest way to do that is to create the model with","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"model = SOSModel(...)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"instead of","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"model = Model(...)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"An alternative equivalent way is to call setpolymodule! after creating the model:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> setpolymodule!(model, SumOfSquares)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This second approach may be useful if the SumOfSquares JuMP extension need to be used with another JuMP extension that also has a special model constructor. A third alternative is the following:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> PolyJuMP.setdefault!(model, PolyJuMP.NonNegPoly, SOSCone)\nNonnegPolyInnerCone{MathOptInterface.PositiveSemidefiniteConeTriangle}\n\njulia> PolyJuMP.setdefault!(model, PolyJuMP.PosDefPolyMatrix, SOSMatrixCone)\nPSDMatrixInnerCone{MathOptInterface.PositiveSemidefiniteConeTriangle}","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"This approach adds the flexibility to choose the default cone for","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraints of the form @constraint(mode, ..., some_polynomial ≥ other_polynomial, ...) which is the cone given as default to PolyJuMP.NonNegPoly; and\nconstraints of the form @constraint(mode, ..., some_matrix_of_polynomial in PSDCone(), ...) or @SDconstraint(mode, ..., some_matrix_of_polynomial ⪰ other_matrix_of_polynomial, ...) which is the cone given as default to PolyJuMP.NonNegPolyMatrix.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"For instance, to use the diagonally-dominant-sum-of-squares cone (see [Definition 2, AM17]) for the first type of contraints, do","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> PolyJuMP.setdefault!(model, PolyJuMP.NonNegPoly, DSOSCone)\nNonnegPolyInnerCone{SumOfSquares.DiagonallyDominantConeTriangle}","category":"page"},{"location":"constraints/#Changing-the-polynomial-basis","page":"Constraints","title":"Changing the polynomial basis","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As introduced in Choosing a polynomial basis, there may be numerical advantages to use another basis than the standard monomial basis when creating polynomial variables. Similarly, other polynomial bases can be used for polynomial constraints. However, for constraints, the polynomial space is determined by the polynomial constrained to be nonnegative. For instance, consider the constraint:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> using DynamicPolynomials\n\njulia> @polyvar x y\n(x, y)\n\njulia> using SumOfSquares\n\njulia> model = SOSModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, α)\nα\n\njulia> @variable(model, β)\nβ\n\njulia> @constraint(model, α * x^2 + β * y^2 ≥ (α - β) * x * y)\n(α)x² + (-α + β)xy + (β)y² is SOS","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"where α and β are JuMP decision variables and x and y are polynomial variables. Since the polynomial is a quadratic form, the sum-of-squares certificate is also a quadratic form (see [Section~3.3.4, BPT12]). Hence the default polynomial basis used for the [Nonnegative polynomial variables] certificate is MonomialBasis([x, y]), that is, we search for a positive semidefinite matrix Q such that","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"alpha x^2 + beta y^2 - (alpha - beta) x y = X^top Q X","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"where X = (x y).","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"As the polynomial space is determined by the polynomial being constrained, only the basis type needs to be given. For instance, to use the scaled monomial basis in the example above, use","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, α * x^2 + β * y^2 ≥ (α - β) * x * y, basis = ScaledMonomialBasis)\n(α)x² + (-α + β)xy + (β)y² is SOS","category":"page"},{"location":"constraints/#Polynomial-nonnegativity-on-a-subset-of-the-space","page":"Constraints","title":"Polynomial nonnegativity on a subset of the space","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"By default, the constraint","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x^3 - x^2 + 2x*y -y^2 + y^3 >= α)\n(1)x³ + (1)y³ + (-1)x² + (2)xy + (-1)y² + (-α) is SOS","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constrains the polynomial to be nonnegative for every real numbers x and y. However, the set of points (x, y) for which the polynomial is constrained to be nonnegative can be specified by the domain keyword:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"julia> S = @set x >= 0 && y >= 0 && x + y >= 1;\n\njulia> @constraint(model, x^3 - x^2 + 2x*y -y^2 + y^3 >= α, domain = S)\n(1)x³ + (1)y³ + (-1)x² + (2)xy + (-1)y² + (-α) is SOS","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See this notebook for a detailed example.","category":"page"},{"location":"constraints/#Dual-of-polynomial-constraints","page":"Constraints","title":"Dual of polynomial constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The dual of a polynomial constraint cref is a moment serie μ as defined in MultivariateMoments. The dual can be obtained with the dual function as with classical dual values in JuMP.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"μ = dual(cref)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"By dual of a Sum-of-Squares constraint, we may mean different things and the meaning chosen for dual function was chosen for consistency with the definition of the JuMP dual function to ensure that generic code will work as expected with Sum-of-Squares constraints. In a Sum-of-Squares constraint, a polynomial p is constraint to be SOS in some domain defined by polynomial q_i. So p(x) is constrained to be equal to s(x) = s_0(x) + s_1(x) * q_1(x) + s_2(x) * q_2(x) + ... where the s_i(x) polynomials are Sum-of-Squares. The dual of the equality constraint between p(x) and s(x) is given by SumOfSquares.PolyJuMP.moments.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"μ = moments(cref)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Note that the dual and moments may give different results. For instance, the output of dual only contains the moments corresponding to monomials of p while the output of moments may give the  moments of other monomials if s(x) has more monomials than p(x). Besides, if the domain contains polynomial, equalities, only the  remainder of p(x) - s(x) modulo the ideal is constrained to be zero, see Corollary 2 of [CLO13]. In that case, the output moments is the dual of the constraint on the remainder so some monomials may have different moments with dual or moments.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The dual of the Sum-of-Squares constraint on s_0(x), commonly referred to as the the matrix of moments can be obtained using moment_matrix:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"ν = moment_matrix(cref)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The extractatoms function of MultivariateMoments can be used to check if there exists an atomic measure (i.e. a measure that is a sum of Dirac measures) that has the moments given in the the moment matrix ν. This can be used for instance in polynomial optimization (see this notebook) or stability analysis (see this notebook).","category":"page"},{"location":"constraints/#References","page":"Constraints","title":"References","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"[CLO13] Cox, D., Little, J., & OShea, D. Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media, 2013.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization. ArXiv e-prints, 2017.","category":"page"},{"location":"constraints/#Reference","page":"Constraints","title":"Reference","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Special case that is second-order cone representable:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.PositiveSemidefinite2x2ConeTriangle","category":"page"},{"location":"constraints/#SumOfSquares.PositiveSemidefinite2x2ConeTriangle","page":"Constraints","title":"SumOfSquares.PositiveSemidefinite2x2ConeTriangle","text":"struct PositiveSemidefinite2x2ConeTriangle <: MOI.AbstractSymmetricMatrixSetTriangle end\n\nCone of positive semidefinite matrices of 2 rows and 2 columns.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Inner approximations of the PSD cone that do not require semidefinite programming:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.DiagonallyDominantConeTriangle\nSumOfSquares.ScaledDiagonallyDominantConeTriangle","category":"page"},{"location":"constraints/#SumOfSquares.DiagonallyDominantConeTriangle","page":"Constraints","title":"SumOfSquares.DiagonallyDominantConeTriangle","text":"struct DiagonallyDominantConeTriangle <: MOI.AbstractSymmetricMatrixSetTriangle\n    side_dimension::Int\nend\n\nSee Definition 4 of [AM17] for a precise definition of the last two items.\n\n[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization ArXiv e-prints, 2017.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.ScaledDiagonallyDominantConeTriangle","page":"Constraints","title":"SumOfSquares.ScaledDiagonallyDominantConeTriangle","text":"struct ScaledDiagonallyDominantConeTriangle <: MOI.AbstractSymmetricMatrixSetTriangle\n    side_dimension::Int\nend\n\nSee Definition 4 of [AM17] for a precise definition of the last two items.\n\n[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization ArXiv e-prints, 2017.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Approximations of the cone of nonnegative polynomials:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.NonnegPolyInnerCone\nSumOfSquares.SOSCone\nSumOfSquares.SDSOSCone\nSumOfSquares.DSOSCone","category":"page"},{"location":"constraints/#SumOfSquares.NonnegPolyInnerCone","page":"Constraints","title":"SumOfSquares.NonnegPolyInnerCone","text":"struct NonnegPolyInnerCone{MCT <: MOI.AbstractVectorSet}\nend\n\nInner approximation of the cone of nonnegative polynomials defined by the set of polynomials of the form\n\nX^\\top Q X\n\nwhere X is a vector of monomials and Q is a symmetric matrix that belongs to the cone psd_inner.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.SOSCone","page":"Constraints","title":"SumOfSquares.SOSCone","text":"const SOSCone = NonnegPolyInnerCone{MOI.PositiveSemidefiniteConeTriangle}\n\nSum-of-squares cone; see NonnegPolyInnerCone.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.SDSOSCone","page":"Constraints","title":"SumOfSquares.SDSOSCone","text":"const SDSOSCone = NonnegPolyInnerCone{ScaledDiagonallyDominantConeTriangle}\n\nScaled-diagonally-dominant-sum-of-squares cone; see [Definition 2, AM17] and NonnegPolyInnerCone.\n\n[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization ArXiv e-prints, 2017.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.DSOSCone","page":"Constraints","title":"SumOfSquares.DSOSCone","text":"const DSOSCone = NonnegPolyInnerCone{DiagonallyDominantConeTriangle}\n\nDiagonally-dominant-sum-of-squares cone; see [Definition 2, AM17] and NonnegPolyInnerCone.\n\n[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization ArXiv e-prints, 2017.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Approximations of the cone of positive semidefinite polynomial matrices:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.PSDMatrixInnerCone\nSumOfSquares.SOSMatrixCone","category":"page"},{"location":"constraints/#SumOfSquares.PSDMatrixInnerCone","page":"Constraints","title":"SumOfSquares.PSDMatrixInnerCone","text":"struct PSDMatrixInnerCone{MCT <: MOI.AbstractVectorSet} <: PolyJuMP.PolynomialSet\nend\n\nInner approximation of the cone of polynomial matrices P(x) that are positive semidefinite for any x defined by the set of n times n polynomial matrices such that the polynomial y^top P(x) y belongs to NonnegPolyInnerCone{MCT} where y is a vector of n auxiliary polynomial variables.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.SOSMatrixCone","page":"Constraints","title":"SumOfSquares.SOSMatrixCone","text":"const SOSMatrixCone = PSDMatrixInnerCone{MOI.PositiveSemidefiniteConeTriangle}\n\nSum-of-squares matrices cone; see [Section 3.3.2, BPT12] and PSDMatrixInnerCone.\n\n[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Approximations of the cone of convex polynomials:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.ConvexPolyInnerCone\nSumOfSquares.SOSConvexCone","category":"page"},{"location":"constraints/#SumOfSquares.ConvexPolyInnerCone","page":"Constraints","title":"SumOfSquares.ConvexPolyInnerCone","text":"struct ConvexPolyInnerCone{MCT} <: PolyJuMP.PolynomialSet end\n\nInner approximation of the set of convex polynomials defined by the set of polynomials such that their hessian belongs to to the set PSDMatrixInnerCone{MCT}()\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.SOSConvexCone","page":"Constraints","title":"SumOfSquares.SOSConvexCone","text":"const SOSConvexCone = ConvexPolyInnerCone{MOI.PositiveSemidefiniteConeTriangle}\n\nSum-of-squares convex polynomials cone; see [Section 3.3.3, BPT12] and ConvexPolyInnerCone.\n\n[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Approximations of the cone of copositive matrices:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.CopositiveInner","category":"page"},{"location":"constraints/#SumOfSquares.CopositiveInner","page":"Constraints","title":"SumOfSquares.CopositiveInner","text":"struct CopositiveInner{S} <: PolyJuMP.PolynomialSet\n    # Inner approximation of the PSD cone, i.e. typically either\n    # `SOSCone`, `DSOSCone` or `SDSOSCone`,\n    psd_inner::S\nend\n\nA symmetric matrix Q is copositive if x^top Q x ge 0 for all vector x in the nonnegative orthant. Checking copositivity is a co-NP-complete problem [MK87] and this cone is only the inner approximation of the cone of copositive symmetric matrices given by Minknowski sum of psd_inner and the cone of symmetric matrices with nonnegative entries (the diagonal entries can be chosen to be zero) [Lemma 3.164, BPT12].\n\nThe matrix with nonnegative entries can be interpreted as lagrangian multipliers. For instance,\n\n@polyvar x y\n@constraint(model, x^2 - 2x*y + y^2 in CopositiveInner(SOSCone()))\n\nis equivalent to\n\n# Matrix that we require to be copositive\nQ = [ 1 -1\n     -1  1]\nλ = @variable(model, lower_bound=0)\n# Symmetric matrix of nonnegative entries\nΛ = [0 λ\n     λ 0]\nusing LinearAlgebra # For `Symmetric`\n@constraint(model, Symmetric(Q - Λ) in PSDCone())\n\nwhich is equivalent to\n\n@polyvar x y\nλ = @variable(model, lower_bound=0)\n@constraint(model, x^2 - 2x*y + y^2 - 2*λ * x*y in SOSCone())\n\nwhich is the same as, using the domain keyword,\n\n@polyvar x y\n@constraint(model, x^2 - 2x*y + y^2 in SOSCone(), domain = @set x*y ≥ 0)\n\nAs an important difference with its equivalent forms, the GramMatrixAttribute for the copositive constraint is given by matrix Q while for the equivalent form using the  domainkeyword, the value of the attribute would correspond to the the gram matrix in thepsd_innercone, i.e. which should be equal toQ - Λ`.\n\n[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.\n\n[MK87] K. G. Murty and S. N. Kabadi. Some NP-complete problems in quadratic and nonlinear programming. Mathematical programming, 39:117–129, 1987.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Types of sparsity","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.Certificate.VariableSparsity\nSumOfSquares.Certificate.MonomialSparsity\nSumOfSquares.Certificate.SignSymmetry","category":"page"},{"location":"constraints/#SumOfSquares.Certificate.VariableSparsity","page":"Constraints","title":"SumOfSquares.Certificate.VariableSparsity","text":"struct VariableSparsity <: Sparsity end\n\nVariable or correlative sparsity as developed in [WSMM06].\n\n[WSMM06] Waki, Hayato, Sunyoung Kim, Masakazu Kojima, and Masakazu Muramatsu. \"Sums of squares and semidefinite program relaxations for polynomial optimization problems with structured sparsity.\" SIAM Journal on Optimization 17, no. 1 (2006): 218-242.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.MonomialSparsity","page":"Constraints","title":"SumOfSquares.Certificate.MonomialSparsity","text":"struct MonomialSparsity{C<:CEG.AbstractCompletion} <: Sparsity\n    completion::C\n    k::Int\n    use_all_monomials::Bool\nend\n\nMonomial or term sparsity as developed in [WML20a, WML20b]. The completion field should be ClusterCompletion() [default] for the block-closure or cluster completion [WML20a], and ChordalCompletion() for chordal completion [WML20b]. The integer k [default=0] corresponds to Σ_k defined in [(3.2), WML20a] and k = 0 corresponds to Σ_* defined in [(3.3), WML20a]. If use_all_monomials is false then some monomials of the basis might be dropped from the basis if not needed.\n\n[WML20a] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. TSSOS: A Moment-SOS hierarchy that exploits term sparsity. arXiv preprint arXiv:1912.08899 (2020).\n\n[WML20b] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. Chordal-TSSOS: a moment-SOS hierarchy that exploits term sparsity with chordal extension. arXiv preprint arXiv:2003.03210 (2020).\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.SignSymmetry","page":"Constraints","title":"SumOfSquares.Certificate.SignSymmetry","text":"struct SignSymmetry <: Sparsity end\n\nSign symmetry as developed in [Section III.C, L09].\n\n[L09] Lofberg, Johan. Pre-and post-processing sum-of-squares programs in practice. IEEE transactions on automatic control 54, no. 5 (2009): 1007-1011.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Ideal certificates:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.Certificate.MaxDegree\nSumOfSquares.Certificate.FixedBasis\nSumOfSquares.Certificate.Newton\nSumOfSquares.Certificate.Remainder\nSumOfSquares.Certificate.SparseIdeal","category":"page"},{"location":"constraints/#SumOfSquares.Certificate.MaxDegree","page":"Constraints","title":"SumOfSquares.Certificate.MaxDegree","text":"struct MaxDegree{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: SimpleIdealCertificate{CT, BT}\n    cone::CT\n    basis::Type{BT}\n    maxdegree::Int\nend\n\nThe MaxDegree certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by exhibiting a Sum-of-Squares polynomials σ(x) such that p(x) - σ(x) is guaranteed to be zero for all x such that h_i(x) = 0. The polynomial σ(x) is search over cone with a basis of type basis such that the degree of σ(x) does not exceed maxdegree.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.FixedBasis","page":"Constraints","title":"SumOfSquares.Certificate.FixedBasis","text":"struct FixedBasis{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: SimpleIdealCertificate{CT, BT}\n    cone::CT\n    basis::BT\nend\n\nThe FixedBasis certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by exhibiting a Sum-of-Squares polynomials σ(x) such that p(x) - σ(x) is guaranteed to be zero for all x such that h_i(x) = 0. The polynomial σ(x) is search over cone with basis basis.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.Newton","page":"Constraints","title":"SumOfSquares.Certificate.Newton","text":"struct Newton{CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis, NPT <: Tuple} <: SimpleIdealCertificate{CT, BT}\n    cone::CT\n    basis::Type{BT}\n    variable_groups::NPT\nend\n\nThe Newton certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by exhibiting a Sum-of-Squares polynomials σ(x) such that p(x) - σ(x) is guaranteed to be zero for all x such that h_i(x) = 0. The polynomial σ(x) is search over cone with a basis of type basis chosen using the multipartite Newton polytope with parts variable_groups. If variable_groups = tuple() then it falls back to the classical Newton polytope with all variables in the same part.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.Remainder","page":"Constraints","title":"SumOfSquares.Certificate.Remainder","text":"struct Remainder{GCT<:AbstractIdealCertificate} <: AbstractIdealCertificate\n    gram_certificate::GCT\nend\n\nThe Remainder certificate ensures the nonnegativity of p(x) for all x such that h_i(x) = 0 by guaranteeing the remainder of p(x) modulo the ideal generated by ⟨h_i⟩ to be nonnegative for all x such that h_i(x) = 0 using the certificate gram_certificate. For instance, if gram_certificate is SumOfSquares.Certificate.Newton, then the certificate Remainder(gram_certificate) will take the remainder before computing the Newton polytope hence might generate a much smaller Newton polytope hence a smaller basis and smaller semidefinite program. However, this then corresponds to a lower degree of the hierarchy which might be insufficient to find a certificate.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.SparseIdeal","page":"Constraints","title":"SumOfSquares.Certificate.SparseIdeal","text":"struct SparseIdeal{S <: Sparsity, C <: AbstractIdealCertificate} <: AbstractIdealCertificate\n    sparsity::S\n    certificate::C\nend\n\nSame certificate as C except that the Sum-of-Squares polynomial σ is modelled as a sum of Sum-of-Squares polynomials with smaller basis using the sparsity reduction sparsity.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Preorder certificates:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.Certificate.Putinar\nSumOfSquares.Certificate.SparsePreorder","category":"page"},{"location":"constraints/#SumOfSquares.Certificate.Putinar","page":"Constraints","title":"SumOfSquares.Certificate.Putinar","text":"struct Putinar{IC <: AbstractIdealCertificate, CT <: SumOfSquares.SOSLikeCone, BT <: MB.AbstractPolynomialBasis} <: AbstractPreorderCertificate\n    ideal_certificate::IC\n    cone::CT\n    basis::Type{BT}\n    maxdegree::Int\nend\n\nThe Putinar certificate ensures the nonnegativity of p(x) for all x such that g_i(x) >= 0 and h_i(x) = 0 by exhibiting Sum-of-Squares polynomials σ_i(x) such that p(x) - ∑ σ_i(x) g_i(x) is guaranteed to be nonnegativity for all x such that h_i(x) = 0. The polynomials σ_i(x) are search over cone with a basis of type basis such that the degree of σ_i(x) g_i(x) does not exceed maxdegree.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.SparsePreorder","page":"Constraints","title":"SumOfSquares.Certificate.SparsePreorder","text":"struct SparsePreorder{S <: Sparsity, C <: AbstractPreorderCertificate} <: AbstractPreorderCertificate\n    sparsity::S\n    certificate::C\nend\n\nSame certificate as C except that the Sum-of-Squares polynomials σ_i are modelled as a sum of Sum-of-Squares polynomials with smaller basis using the sparsity reduction sparsity.\n\n\n\n\n\n","category":"type"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Attributes","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.PolyJuMP.MomentsAttribute\nSumOfSquares.MultivariateMoments.moments(::SumOfSquares.JuMP.ConstraintRef)\nGramMatrix\nSumOfSquares.GramMatrixAttribute\ngram_matrix\ngram_operate\nSumOfSquares.MomentMatrixAttribute\nmoment_matrix\nSumOfSquares.CertificateBasis\ncertificate_basis\ncertificate_monomials\nSumOfSquares.LagrangianMultipliers\nlagrangian_multipliers\nSOSDecomposition\nSOSDecompositionWithDomain\nsos_decomposition","category":"page"},{"location":"constraints/#PolyJuMP.MomentsAttribute","page":"Constraints","title":"PolyJuMP.MomentsAttribute","text":"MomentsAttribute(N)\nMomentsAttribute()\n\nA constraint attribute for the vector of moments corresponding to the constraint that a polynomial is zero in the full space in result N. If the polynomial is constrained to be zero in an algebraic set, it is the moments for the constraint once it is rewritten into an constraint on the full space. If N is omitted, it is 1 by default.\n\nExamples\n\nConsider the following program:\n\n@variable(model, α)\n@variable(model, β ≤ 1)\n\nusing DynamicPolynomials\n@polyvar x y\ncref = @constraint(model, α * x - β * y == 0, domain = @set x == y)\n\nThe constraint is equivalent to\n\n@constraint(model, (α - β) * y == 0)\n\nfor which the dual is the 1-element vector with the moment of y of value -1. This is the result of moments(cref). However, the dual of cref obtained by dual(cref) is the 2-elements vector with both the moments of x and y of value -1.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#MultivariateMoments.moments-Tuple{ConstraintRef}","page":"Constraints","title":"MultivariateMoments.moments","text":"moments(cref::JuMP.ConstraintRef)\n\nReturn the MomentsAttribute of cref.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#SumOfSquares.GramMatrix","page":"Constraints","title":"SumOfSquares.GramMatrix","text":"struct GramMatrix{T, B, U, MT <: AbstractMatrix{T}} <: AbstractGramMatrix{T, B, U}\n    Q::MT\n    basis::B\nend\n\nGram matrix x^top Q x where Q is a symmetric matrix indexed by the vector of polynomials of the basis basis.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.GramMatrixAttribute","page":"Constraints","title":"SumOfSquares.GramMatrixAttribute","text":"GramMatrixAttribute(N)\nGramMatrixAttribute()\n\nA constraint attribute for the GramMatrix of a constraint, that is, the positive semidefinite matrix Q indexed by the monomials in the vector X such that X^top Q X is the sum-of-squares certificate of the constraint.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.gram_matrix","page":"Constraints","title":"SumOfSquares.gram_matrix","text":"gram_matrix(cref::JuMP.ConstraintRef)\n\nReturn the GramMatrixAttribute of cref.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.gram_operate","page":"Constraints","title":"SumOfSquares.gram_operate","text":"gram_operate(::typeof(+), p::GramMatrix, q::GramMatrix)\n\nComputes the Gram matrix equal to the sum between p and q. On the opposite, p + q gives a polynomial equal to p + q. The polynomial p + q can also be obtained by polynomial(gram_operate(+, p, q)).\n\n\n\n\n\ngram_operate(/, p::GramMatrix, α)\n\nComputes the Gram matrix equal to p / α. On the opposite, p / α gives a polynomial equal to p / α. The polynomial p / α can also be obtained by polynomial(gram_operate(/, p, α)).\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.MomentMatrixAttribute","page":"Constraints","title":"SumOfSquares.MomentMatrixAttribute","text":"MomentMatrixAttribute(N)\nMomentMatrixAttribute()\n\nA constraint attribute fot the MomentMatrix of a constraint.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#MultivariateMoments.moment_matrix","page":"Constraints","title":"MultivariateMoments.moment_matrix","text":"moment_matrix(cref::JuMP.ConstraintRef)\n\nReturn the MomentMatrixAttribute of cref.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.CertificateBasis","page":"Constraints","title":"SumOfSquares.CertificateBasis","text":"struct CertificateBasis <: MOI.AbstractConstraintAttribute end\n\nA constraint attribute for the basis indexing the GramMatrixAttribute and MomentMatrixAttribute certificates.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.certificate_basis","page":"Constraints","title":"SumOfSquares.certificate_basis","text":"certificate_basis(cref::JuMP.ConstraintRef)\n\nReturn the CertificateBasis of cref.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.certificate_monomials","page":"Constraints","title":"SumOfSquares.certificate_monomials","text":"certificate_monomials(cref::JuMP.ConstraintRef)\n\nReturn the monomials of certificate_basis. If the basis if not MultivariateBases.AbstractMonomialBasis, an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.LagrangianMultipliers","page":"Constraints","title":"SumOfSquares.LagrangianMultipliers","text":"LagrangianMultipliers(N)\nLagrangianMultipliers()\n\nA constraint attribute fot the LagrangianMultipliers associated to the inequalities of the domain of a constraint. There is one multiplier per inequality and no multiplier for equalities as the equalities are handled by reducing the polynomials over the ideal they generate instead of explicitely creating multipliers.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.lagrangian_multipliers","page":"Constraints","title":"SumOfSquares.lagrangian_multipliers","text":"lagrangian_multipliers(cref::JuMP.ConstraintRef)\n\nReturn the LagrangianMultipliers of cref.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.SOSDecomposition","page":"Constraints","title":"SumOfSquares.SOSDecomposition","text":"struct SOSDecomposition{T, PT}\n\nRepresend SOSDecomposition without domain\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.SOSDecompositionWithDomain","page":"Constraints","title":"SumOfSquares.SOSDecompositionWithDomain","text":"struct SOSDecompositionWithDomain{T, PT, S}\n\nRepresend SOSDecomposition on a basic semi-algebraic domain.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.sos_decomposition","page":"Constraints","title":"SumOfSquares.sos_decomposition","text":"function sos_decomposition(cref::JuMP.ConstraintRef, ranktol::Float64, dec::MultivariateMoments.lowrankchol)\n\nReturn representation as a sum of squares.\n\n\n\n\n\nsos_decomposition(cref::JuMP.ConstraintRef, K<:AbstractBasicSemialgebraicSet)\n\nReturn representation in the quadraic module associated with K.\n\n\n\n\n\n","category":"function"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Bridges are automatically added using the following utilities:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.PolyJuMP.bridgeable\nSumOfSquares.PolyJuMP.bridges","category":"page"},{"location":"constraints/#PolyJuMP.bridgeable","page":"Constraints","title":"PolyJuMP.bridgeable","text":"bridgeable(c::JuMP.AbstractConstraint, F::Type{<:MOI.AbstractFunction},\n           S::Type{<:MOI.AbstractSet})\n\nWrap the constraint c in JuMP.BridgeableConstraints that may be needed to bridge F-in-S constraints.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PolyJuMP.bridges","page":"Constraints","title":"PolyJuMP.bridges","text":"bridges(F::Type{<:MOI.AbstractFunction}, S::Type{<:MOI.AbstractSet})\n\nReturn a list of bridges that may be needed to bridge F-in-S constraints but not the bridges that may be needed by constraints added by the bridges.\n\n\n\n\n\nbridges(S::Type{<:MOI.AbstractSet})\n\nReturn a list of bridges that may be needed to bridge constrained variables in S but not the bridges that may be needed by constraints added by the bridges.\n\n\n\n\n\n","category":"function"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Chordal extension:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"SumOfSquares.Certificate.ChordalExtensionGraph.neighbors\nSumOfSquares.Certificate.ChordalExtensionGraph.fill_in\nSumOfSquares.Certificate.ChordalExtensionGraph.is_clique\nSumOfSquares.Certificate.ChordalExtensionGraph.LabelledGraph\nSumOfSquares.Certificate.ChordalExtensionGraph.add_node!\nSumOfSquares.Certificate.ChordalExtensionGraph.add_edge!\nSumOfSquares.Certificate.ChordalExtensionGraph.add_clique!\nSumOfSquares.Certificate.ChordalExtensionGraph.completion","category":"page"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.neighbors","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.neighbors","text":"neighbors(G::Graph, node::Int}\n\nReturn neighbors of node in G.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.fill_in","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.fill_in","text":"fill_in(G::Graph{T}, i::T}\n\nReturn number of edges that need to be added to make the neighbors of i a clique.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.is_clique","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.is_clique","text":"is_clique(G::Graph{T}, x::Vector{T})\n\nReturn a Bool indication whether x is a clique in G.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.LabelledGraph","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.LabelledGraph","text":"struct LabelledGraph{T}\n    n2int::Dict{T,Int}\n    int2n::Vector{T}\n    graph::Graph\nend\n\nType to represend a graph with nodes of type T.\n\n\n\n\n\n","category":"type"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.add_node!","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.add_node!","text":"add_node!(G::LabelledGraph{T}, i::T) where T\n\nAdd the node i to graph G. If i is already a node of G, only return the reference.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.add_edge!","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.add_edge!","text":"add_edge!(G::LabelledGraph{T}, i::T, j::T) where T\n\nAdd the unweighted edge (i, j) to graph G. Duplicate edges are not taken into account.\n\n\n\n\n\nadd_edge!(G::LabelledGraph{T}, e::Tuple{T,T}) where T\n\nAdd the unweighted edge e to graph G. Duplicate edges are not taken into account.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.add_clique!","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.add_clique!","text":"add_clique!(G::LabelledGraph{T}, x::Vector{T}) where T\n\nAdd all elements of x as nodes to G and add edges such that x is fully connected in G.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#SumOfSquares.Certificate.ChordalExtensionGraph.completion","page":"Constraints","title":"SumOfSquares.Certificate.ChordalExtensionGraph.completion","text":"completion(G::Graph, comp::ChordalCompletion)\n\nReturn a chordal extension of G and the corresponding maximal cliques.\n\nThe algoritm is Algorithm 3 in [BA10] with the GreedyFillIn heuristic of Table I.\n\n[BA10] Bodlaender, Hans L., and Arie MCA Koster. Treewidth computations I. Upper bounds. Information and Computation 208, no. 3 (2010): 259-275. Utrecht University, Utrecht, The Netherlands www.cs.uu.nl\n\n\n\n\n\ncompletion(G::Graph, comp::ChordalCompletion)\n\nReturn a cluster completion of G and the corresponding maximal cliques.\n\n\n\n\n\n","category":"function"},{"location":"generated/Sums of Hermitian squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Sums of Hermitian squares.jl\"","category":"page"},{"location":"generated/Sums of Hermitian squares/#Sums-of-Hermitian-squares","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"","category":"section"},{"location":"generated/Sums of Hermitian squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"(Image: ) (Image: ) Contributed by: Benoît Legat","category":"page"},{"location":"generated/Sums of Hermitian squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"using SumOfSquares\n\nusing DynamicPolynomials\n@ncpolyvar x y\np = (x + 1.0im * y) * (x - im * y)\n\nimport CSDP\nmodel = Model(CSDP.Optimizer)\nadd_bridge(model, SumOfSquares.Bridges.Constraint.EmptyBridge)\nadd_bridge(model, SumOfSquares.Bridges.Constraint.PositiveSemidefinite2x2Bridge)\nadd_bridge(model, SumOfSquares.COI.Bridges.Variable.HermitianToSymmetricPSDBridge)\nadd_bridge(model, SumOfSquares.COI.Bridges.Constraint.SplitZeroBridge)\nMOI.Bridges.add_bridge(backend(model).optimizer, PolyJuMP.ZeroPolynomialBridge{Complex{Float64}})\nMOI.Bridges.add_bridge(backend(model).optimizer, SumOfSquares.Bridges.Constraint.SOSPolynomialBridge{Complex{Float64}})\ncone = NonnegPolyInnerCone{SumOfSquares.COI.HermitianPositiveSemidefiniteConeTriangle}()\ncertificate = SumOfSquares.Certificate.MaxDegree(cone, MonomialBasis, 2)\nc = SumOfSquares.add_constraint(model, p, cone, ideal_certificate = certificate)\noptimize!(model)\nsos_decomposition(c, 1e-6) #!src","category":"page"},{"location":"generated/Sums of Hermitian squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"","category":"page"},{"location":"generated/Sums of Hermitian squares/","page":"Sums of Hermitian squares","title":"Sums of Hermitian squares","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Symmetry reduction.jl\"","category":"page"},{"location":"generated/Symmetry reduction/#Symmetry-reduction","page":"Symmetry reduction","title":"Symmetry reduction","text":"","category":"section"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"(Image: ) (Image: ) Adapted from: https://github.com/kalmarek/SymbolicWedderburn.jl/blob/tw/exsos/examples/exC4.jl","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"using Pkg\npkg\"add https://github.com/kalmarek/SymbolicWedderburn.jl#bl/nonperm\"\n\nimport MutableArithmetics\nconst MA = MutableArithmetics\nusing MultivariatePolynomials\nconst MP = MultivariatePolynomials\nusing MultivariateBases\nconst MB = MultivariateBases\n\nusing DynamicPolynomials\n@polyvar x[1:4]","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We would like to find the minimum value of the polynomial","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"poly = sum(x) + sum(x.^2)","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"As we can decouple the problem for each x[i] for which x[i] + x[i]^2 has minimum value 0.25, we would expect to get -1 as answer. Can this decoupling be exploited by SumOfSquares as well ? For this, we need to use a certificate that can exploit the permutation symmetry of the polynomial. This is still a work in progress in SumOfSquares, so we need to define things here:","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"using SymbolicWedderburn\nusing PermutationGroups\nusing Cyclotomics\nusing SumOfSquares\n\nfunction SymbolicWedderburn.ExtensionHomomorphism(basis::MB.MonomialBasis)\n    monos = basis.monomials\n    basis_exps = Vector{Vector{Int}}(undef, length(monos))\n    basis_dict = Dict{Vector{Int}, Int}()\n    sizehint!(basis_dict, length(monos))\n\n    for (i, b) in enumerate(monos)\n        e = MP.exponents(b) # so that we allocate exponents only once\n        basis_exps[i] = e\n        basis_dict[e] = i\n    end\n\n    return SymbolicWedderburn.ExtensionHomomorphism(basis_exps, basis_dict)\nend\nfunction MP.polynomialtype(::Type{<:MB.AbstractPolynomialVectorBasis{PT}}, T::Type) where PT\n    C = MP.coefficienttype(PT)\n    U = MA.promote_operation(*, C, T)\n    V = MA.promote_operation(+, U, U)\n    return MP.polynomialtype(PT, V)\nend\nstruct SymmetricIdeal{CT, GT} <: Certificate.AbstractIdealCertificate\n    cone::CT\n    group::GT\nend\nSumOfSquares.matrix_cone_type(::Type{<:SymmetricIdeal{CT}}) where {CT} = SumOfSquares.matrix_cone_type(CT)\nCertificate.get(::Type{<:SymmetricIdeal}, ::SumOfSquares.Certificate.GramBasisType) = Vector{MB.FixedPolynomialBasis}\nCertificate.zero_basis_type(::Type{<:SymmetricIdeal}) = MB.MonomialBasis\nCertificate.zero_basis(::SymmetricIdeal) = MB.MonomialBasis\nCertificate.get(::SymmetricIdeal, ::Certificate.ReducedPolynomial, poly, domain) = poly\nfunction Certificate.get(cert::SymmetricIdeal, ::Certificate.GramBasis, poly)\n    basis = Certificate.maxdegree_gram_basis(MB.MonomialBasis, MP.variables(poly), MP.maxdegree(poly))\n    R = SymbolicWedderburn.symmetry_adapted_basis(cert.group, basis)\n    return map(R) do Ri\n        FixedPolynomialBasis(convert(Matrix{Float64}, Ri) * basis.monomials)\n    end\nend\nG = PermGroup([perm\"(1,2,3,4)\"])","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We can use this certificate as follows:","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"import CSDP\nsolver = CSDP.Optimizer\nmodel = Model(solver)\n@variable(model, t)\n@objective(model, Max, t)\ncon_ref = @constraint(model, poly - t in SOSCone(), ideal_certificate = SymmetricIdeal(SOSCone(), G))\noptimize!(model)\nvalue(t)","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"We indeed find -1, let's verify that symmetry was exploited:","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"gram_matrix(con_ref)","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"","category":"page"},{"location":"generated/Symmetry reduction/","page":"Symmetry reduction","title":"Symmetry reduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Sum-of-Squares Matrices.jl\"","category":"page"},{"location":"generated/Sum-of-Squares Matrices/#Sum-of-Squares-matrices","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares matrices","text":"","category":"section"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"(Image: ) (Image: ) Adapted from: Examples 3.77 of [BPT12]","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/#Introduction","page":"Sum-of-Squares Matrices","title":"Introduction","text":"","category":"section"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"Consider the symmetric polynomial matrix P(x) = beginbmatrix     x^2 - 2x + 2  x\n    x             x^2 endbmatrix We could like to know whether P(x) is positive semidefinite for all x in mathbbR.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"using DynamicPolynomials\n@polyvar x\nP = [x^2 - 2x + 2 x\n            x     x^2]","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"A sufficient condition for a symmetric polynomial matrix P(x) to be positive semidefinite for all x is to the existence of a matrix M(x) such that P(x) = M^top(x) M(x). If such matrix M exists, we say that the matrix is an \\emph{sos matrix} (see [Definition 3.76, BPT13]). While determining whether P(x) is positive semidefinite for all x, is NP-hard (checking nonnegativity of a polynomial is reduced to this problem for 1 times 1 matrices), checking whether P(x) is an sos matrix is an sos program.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"using SumOfSquares","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"import CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\n\nmodel = SOSModel(solver)\nmat_cref = @constraint(model, P in PSDCone())\noptimize!(model)\ntermination_status(model) #!src","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"While the reformulation of sos matrix to sos polynomial is rather simple, as explained in the \"Sum-of-Squares reformulation\" section below, there is a technical subtelty about the Newton polytope that if not handled correctly may result in an SDP of large size with bad numerical behavior. For this reason, it is recommended to model sos matrix constraints as such as will be shown in this notebook and not do the formulation manually unless there is a specific reason to do so.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"As we can verify as follows, only 3 monomials are used using the sos matrix constraint.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"certificate_monomials(mat_cref)","category":"page"},{"location":"generated/Sum-of-Squares Matrices/#Sum-of-Squares-reformulation","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares reformulation","text":"","category":"section"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"One way to obtain the reduction to an sos program is to create an intermediate vector of variable y and check whether the polynomial p(x y) = y^top P(x) y is sos. However, special care is required when approximating the Newton polytope of p(x y). Indeed, for instance if the entries of P(x) are quadratic forms then the Newton polytope of p(x y) is the cartesian product between the Newton polytope of y^top y and the Newton polytope of x^top x. In other words, p(x y) belongs to a family of quartic forms called biquadratic forms. This fact is important when generating the semidefinite program so that only bilinear monomials are used. So if the cheap outer approximation is used (instead of the exact polyhedral computation) for the newton polytope then it is important to use a multipartite computation approximation of the newton polytope. The multipartie exact approach may perform worse compared to the unipartite exact in certain cases though. Consider for instance the polynomial matrix mathrmDiag(x_1^1 x_2^2) for which p(x y) = x_1^2y_1^2 + x_2^2y_2^2. For this polynomial, only the monomials x_1y_1 and x_2y_2 are needed in the SDP reformulation while the multipartite approach, as it will compute the Newton polytope as a cartesian product, will not see the dependence between x and y in the presence of monomials and will also select the monomials x_1y_2 and x_2y_1.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"@polyvar y[1:2]\np = vec(y)' * P * vec(y)","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"We can see above that p is biquadratic polynomial in the variables x and y. Computing the Newton polytope with the cheap outer approximation without exploiting this multipartite structure gives the following 6 monomials.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"X = monomials(p)\nCertificate.monomials_half_newton_polytope(X, tuple(), apply_post_filter = false)","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"Exploiting the multipartite structure gives 4 monomials.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"Certificate.monomials_half_newton_polytope(X, ([x], y), apply_post_filter = false)","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"In the example above, there were only 3 monomials, where does the difference come from ? Using the monomial basis, the only product of two monomials that is equal to y[2]^2 is y[2] * y[2]. As y[2]^2 is not a monomial of p, we can conclude that the diagonal entry with row and column corresponding to y[2] will be zero hence the whole column and row will be zero as well. Therefore, we can remove this monomial.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"Certificate.monomials_half_newton_polytope(X, ([x], y))","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"The same reasoning can be used for monomials y[1]y[2] and x therefore whether we exploit the multipartite structure or not, we get only 3 monomials thanks to this post filter.","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"Certificate.monomials_half_newton_polytope(X, tuple())","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"","category":"page"},{"location":"generated/Sum-of-Squares Matrices/","page":"Sum-of-Squares Matrices","title":"Sum-of-Squares Matrices","text":"This page was generated using Literate.jl.","category":"page"},{"location":"variables/#Polynomial-and-Sum-of-Squares-variables","page":"Variables","title":"Polynomial and Sum-of-Squares variables","text":"","category":"section"},{"location":"variables/#Polynomial-variables","page":"Variables","title":"Polynomial variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"While JuMP allows to create decision variables representing a number whose value needs to be optimized upon by the optimizer, PolyJuMP allows to create polynomial decision variables. In order to do that, we first need to create polynomial variables with the @polyvar macro:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> using DynamicPolynomials # or TypedPolynomials, pick your favorite\n\njulia> @polyvar x y\n(x, y)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Note that these should not be confused with JuMP's decision variables which are created using the @variable macro. The polynomial decision variable that will be created need to be parametrized by a polynomial basis of finite size. For instance, if we want to find a quadratic polynomial, we can parametrize it with all monomials of degree between 0 and 2. Generating a vector with such monomials can be achieved through the monomials function:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> X = monomials([x, y], 0:2)\n6-element MonomialVector{true}:\n x²\n xy\n y²\n x\n y\n 1","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"We can now create our polynomial variable p as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> using SumOfSquares\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, p, Poly(X))\n(noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"This creates a vector of decision variables a and sets p as the scalar product between a and X.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Just like with classical JuMP's decision variables, containers of polynomial variables can be created as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, [1:3, 1:4], Poly(X))       # Creates a Matrix\n3×4 Array{Polynomial{true,VariableRef},2}:\n (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)  …  (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)\n (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)     (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)\n (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)     (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)\n\njulia> @variable(model, [[:a, :b], -2:2], Poly(X)) # Creates a JuMPArray\n2-dimensional DenseAxisArray{DynamicPolynomials.Polynomial{true,VariableRef},2,...} with index sets:\n    Dimension 1, [:a, :b]\n    Dimension 2, -2:2\nAnd data, a 2×5 Array{DynamicPolynomials.Polynomial{true,VariableRef},2}:\n (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)  …  (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)\n (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)     (noname)x² + (noname)xy + (noname)y² + (noname)x + (noname)y + (noname)\n\njulia> @variable(model, [i=1:3, j=i:3], Poly(X))   # Creates a Dict\nJuMP.Containers.SparseAxisArray{Polynomial{true,VariableRef},2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  (noname)*x^2 + (noname)*x*y + (noname)*y^2 + (noname)*x + (noname)*y + (noname)\n  [2, 3]  =  (noname)*x^2 + (noname)*x*y + (noname)*y^2 + (noname)*x + (noname)*y + (noname)\n  [3, 3]  =  (noname)*x^2 + (noname)*x*y + (noname)*y^2 + (noname)*x + (noname)*y + (noname)\n  [2, 2]  =  (noname)*x^2 + (noname)*x*y + (noname)*y^2 + (noname)*x + (noname)*y + (noname)\n  [1, 1]  =  (noname)*x^2 + (noname)*x*y + (noname)*y^2 + (noname)*x + (noname)*y + (noname)\n  [1, 3]  =  (noname)*x^2 + (noname)*x*y + (noname)*y^2 + (noname)*x + (noname)*y + (noname)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For more flexibility, polynomials parametrized by decision variables can also be created \"by hand\" for instance as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, α)\nα\n\njulia> @variable(model, β)\nβ\n\njulia> p = α*x^2 + (α+β)*y^2*x + β*y^3\n(α + β)xy² + (β)y³ + (α)x²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"The coefficients of the polynomial can even be quadratic, e.g.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> p = (3α^2+β)*x^2 + (α*β+2β)*y^2*x + β*y^3\n(α*β + 2 β)xy² + (β)y³ + (3 α² + β)x²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Let me stress again the distinction between α and β which are decision variables and x and y which are polynomial variables.","category":"page"},{"location":"variables/#Nonnegative-polynomial-variables","page":"Variables","title":"Nonnegative polynomial variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In order to create a sum-of-squares polynomial variable, the syntax is exactly the same except SOSPoly should be used instead of Poly. For instance, the following code creates a 3 times 4 matrix of sum-of-squares polynomial variables:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, [1:2], SOSPoly(X))\n2-element Array{GramMatrix{VariableRef,MonomialBasis{Monomial{true},MonomialVector{true}},GenericAffExpr{Float64,VariableRef},SymMatrix{VariableRef}},1}:\n GramMatrix{VariableRef,MonomialBasis{Monomial{true},MonomialVector{true}},GenericAffExpr{Float64,VariableRef},SymMatrix{VariableRef}}(VariableRef[noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], MonomialBasis{Monomial{true},MonomialVector{true}}(DynamicPolynomials.Monomial{true}[x², xy, y², x, y, 1]))\n GramMatrix{VariableRef,MonomialBasis{Monomial{true},MonomialVector{true}},GenericAffExpr{Float64,VariableRef},SymMatrix{VariableRef}}(VariableRef[noname noname … noname noname; noname noname … noname noname; … ; noname noname … noname noname; noname noname … noname noname], MonomialBasis{Monomial{true},MonomialVector{true}}(DynamicPolynomials.Monomial{true}[x², xy, y², x, y, 1]))","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"There is however an important difference between the meaning of the vector of monomials X between Poly and SOSPoly. For SOSPoly, it creates a positive semidefinite matrix of variables Q and sets p as the value of X' * Q * X. That is, for instance, if X contains all the monomials of degree 2, then all the monomials of p will have degree 4 (i.e. p will be a quartic form).","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Similarly, to create diagonally-dominant-sum-of-squares polynomial variables (see [Definition 3.1, AM17]), use DSOSPoly(X). This creates a diagonally dominant matrix of variables Q and sets the polynomial variables as the value of X' * Q * X.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Finally, to create scaled-diagonally-dominant-sum-of-squares polynomial variables (see [Definition 3.2, AM17]), use SDSOSPoly(X). This creates a scaled diagonally dominant matrix of variables Q and sets the polynomial variables as the value of X' * Q * X.","category":"page"},{"location":"variables/#Choosing-a-polynomial-basis","page":"Variables","title":"Choosing a polynomial basis","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"In the previous section, we show how to create polynomial variables from a monomial basis. However, the monomial basis is only a particular case of polynomial basis and while using a different basis of the same space of polynomial is would give an equivalent program, it might be more stable numerically (see [Section 3.1.5, BPT12]).","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"For instance, creating an univariate cubic polynomial variable p using the Chebyshev basis can be done as follows:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> cheby_basis = FixedPolynomialBasis([1, x, 2x^2-1, 4x^3-3x])\nFixedPolynomialBasis{Polynomial{true,Int64},Array{Polynomial{true,Int64},1}}(DynamicPolynomials.Polynomial{true,Int64}[1, x, 2x² - 1, 4x³ - 3x])\n\njulia> @variable(model, variable_type=Poly(cheby_basis))\n(4 noname)x³ + (2 noname)x² + (noname - 3 noname)x + (noname - noname)","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"and to create a quadratic form variable q using the scaled monomial basis (see [Section 3.1.5, BPT12]), use the following:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> X = monomials([x, y], 2)\n3-element MonomialVector{true}:\n x²\n xy\n y²\n\njulia> scaled_basis = ScaledMonomialBasis(X)\nScaledMonomialBasis{Monomial{true},MonomialVector{true}}(DynamicPolynomials.Monomial{true}[x², xy, y²])\n\njulia> @variable(model, variable_type=Poly(scaled_basis))\n(noname)x² + (1.4142135623730951 noname)xy + (noname)y²","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"which is equivalent to","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"julia> scaled_basis = FixedPolynomialBasis([x^2, √2*x*y, y^2])\nFixedPolynomialBasis{Term{true,Float64},Array{Term{true,Float64},1}}(DynamicPolynomials.Term{true,Float64}[x², 1.4142135623730951xy, y²])\n\njulia> @variable(model, variable_type=Poly(scaled_basis))\n(noname)x² + (1.4142135623730951 noname)xy + (noname)y²","category":"page"},{"location":"variables/#References","page":"Variables","title":"References","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization ArXiv e-prints, 2017.","category":"page"},{"location":"variables/#Reference","page":"Variables","title":"Reference","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"SumOfSquares.PolyJuMP.Poly","category":"page"},{"location":"variables/#PolyJuMP.Poly","page":"Variables","title":"PolyJuMP.Poly","text":"struct Poly{PB<:AbstractPolynomialBasis} <: AbstractPoly\n    polynomial_basis::PB\nend\n\nPolynomial variable v^top p where v is a vector of new decision variables and p is a vector of polynomials for the basis polynomial_basis.\n\n\n\n\n\n","category":"type"},{"location":"variables/","page":"Variables","title":"Variables","text":"Variable bridges:","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"SumOfSquares.Bridges.Variable.ScaledDiagonallyDominantBridge","category":"page"},{"location":"variables/#SumOfSquares.Bridges.Variable.ScaledDiagonallyDominantBridge","page":"Variables","title":"SumOfSquares.Bridges.Variable.ScaledDiagonallyDominantBridge","text":"struct ScaledDiagonallyDominantBridge{T} <: MOI.Bridges.Variable.AbstractBridge\n    side_dimension::Int\n    variables::Vector{Vector{MOI.VariableIndex}}\n    constraints::Vector{MOI.ConstraintIndex{\n        MOI.VectorOfVariables, SOS.PositiveSemidefinite2x2ConeTriangle}}\nend\n\nA matrix is SDD iff it is the sum of psd matrices Mij that are zero except for entries ii, ij and jj [Lemma 9, AM17]. This bridge substitute the constrained variables in SumOfSquares.ScaledDiagonallyDominantConeTriangle into a sum of constrained variables in SumOfSquares.PositiveSemidefinite2x2ConeTriangle.\n\n[AM17] Ahmadi, A. A. & Majumdar, A. DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization ArXiv e-prints, 2017.\n\n\n\n\n\n","category":"type"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Bound on Global Extremum.jl\"","category":"page"},{"location":"generated/Bound on Global Extremum/#Bound-on-Global-Extremum","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"","category":"section"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO3 (See Section 4.3 of SOSTOOLS User's Manual)","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"using DynamicPolynomials\n@polyvar x1 x2","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"The Goldstein-Price function f(x) is defined as follows:","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"f1 = x1 + x2 + 1\nf2 = 19 - 14x1 + 3x1^2 - 14x2 + 6x1*x2 + 3x2^2\nf3 = 2x1 - 3x2\nf4 = 18 - 32x1 + 12x1^2 + 48x2 - 36x1*x2 + 27x2^2\nf = (1 + f1^2 * f2) * (30 + f3^2 * f4)","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"using SumOfSquares\nusing CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver);\nnothing #hide","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We create the decision variable gamma that will be the lower bound to the Goldstein-Price function. We maximize it to have the highest possible lower bound.","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"@variable(model, γ)\n@objective(model, Max, γ)","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We constrain gamma to be a lower bound with the following constraint that ensures that f(x_1 x_2) ge gamma for all x_1 x_2.","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"@constraint(model, f >= γ)\n\nJuMP.optimize!(model)","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We verify that the solver has found a feasible solution:","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"JuMP.primal_status(model)","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"We can now obtain the lower bound either with value(γ) or objective_value(model):","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"objective_value(model)","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"","category":"page"},{"location":"generated/Bound on Global Extremum/","page":"Bound on Global Extremum","title":"Bound on Global Extremum","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Term sparsity.jl\"","category":"page"},{"location":"generated/Term sparsity/#Term-sparsity","page":"Term sparsity","title":"Term sparsity","text":"","category":"section"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"(Image: ) (Image: ) Adapted from: Example 3.5 of [WML20b]","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[WML20a] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. TSSOS: A Moment-SOS hierarchy that exploits term sparsity. arXiv preprint arXiv:1912.08899 (2020).","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[WML20b] Wang, Jie, Victor Magron, and Jean-Bernard Lasserre. Chordal-TSSOS: a moment-SOS hierarchy that exploits term sparsity with chordal extension. arXiv preprint arXiv:2003.03210 (2020).","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"using DynamicPolynomials\n@polyvar x[1:3]","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"We would like to find the minimum value of the polynomial","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"poly = x[1]^2 - 2x[1]*x[2] + 3x[2]^2 - 2x[1]^2*x[2] + 2x[1]^2*x[2]^2 - 2x[2]*x[3] + 6x[3]^2 + 18x[2]^2*x[3] - 54x[2]*x[3]^2 + 142x[2]^2*x[3]^2","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"The minimum value of the polynomial can be found to be zero.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"import CSDP\nsolver = CSDP.Optimizer\nusing SumOfSquares\nfunction sos_min(sparsity)\n    model = Model(solver)\n    @variable(model, t)\n    @objective(model, Max, t)\n    con_ref = @constraint(model, poly - t in SOSCone(), sparsity = sparsity)\n    optimize!(model)\n    return value(t), moment_matrix(con_ref)\nend\n\nbound, ν = sos_min(NoSparsity())\nbound","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"We find the corresponding minimizer (0, 0, 0) by matching the moments of the moment matrix with a dirac measure centered at this minimizer.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"extractatoms(ν, 1e-6)","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"We can see below that the basis contained 6 monomials hence we needed to use 6x6 PSD matrix variables.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"ν.basis","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"Using the monomial/term sparsity method of [WML20a] based on cluster completion, we find the same bound.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"bound, ν = sos_min(MonomialSparsity())\nbound","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"Which is not suprising as no sparsity reduction could be performed.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[sub.basis for sub in ν.sub_moment_matrices]","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"Using the monomial/term sparsity method of [WML20b] based on chordal completion, the lower bound is smaller than 0.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"bound, ν = sos_min(MonomialSparsity(ChordalCompletion()))\nbound","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"However, this bound was obtained with an SDP with 4 matrices of size 3x3.","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"[sub.basis for sub in ν.sub_moment_matrices]","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"","category":"page"},{"location":"generated/Term sparsity/","page":"Term sparsity","title":"Term sparsity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Lyapunov Function Search.jl\"","category":"page"},{"location":"generated/Lyapunov Function Search/#Lyapunov-Function-Search","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"","category":"section"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"(Image: ) (Image: ) Adapted from: SOSTOOLS' SOSDEMO2 (See Section 4.2 of SOSTOOLS User's Manual)","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"using DynamicPolynomials\n@polyvar x[1:3]","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We define below the vector field textdxtextdt = f","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"f = [-x[1]^3 - x[1] * x[3]^2,\n     -x[2] - x[1]^2 * x[2],\n     -x[3] - 3x[3] / (x[3]^2 + 1) + 3x[1]^2 * x[3]]","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We need to pick an SDP solver, see here for a list of the available choices. We use SOSModel instead of Model to be able to use the >= syntax for Sum-of-Squares constraints.","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"using SumOfSquares\nusing CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver);\nnothing #hide","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We are searching for a Lyapunov function V(x) with monomials x_1^2, x_2^2 and x_3^2. We first define the monomials to be used for the Lyapunov function:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"monos = x.^2","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We now define the Lyapunov function as a polynomial decision variable with these monomials:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"@variable(model, V, Poly(monos))","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We need to make sure that the Lyapunov function is strictly positive. We can do this with a constraint V(x) ge epsilon (x_1^2 + x_2^2 + x_3^2), let's pick epsilon = 1:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"@constraint(model, V >= sum(x.^2))","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We now compute textdVtextdx cdot f.","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"using LinearAlgebra # Needed for `dot`\ndVdt = dot(differentiate(V, x), f)","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"The denominator is x3^2 + 1 is strictly positive so the sign of dVdt is the same as the sign of its numerator.","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"P = dVdt.num","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"Hence, we constrain this numerator to be nonnegative:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"@constraint(model, P <= 0)","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"The model is ready to be optimized by the solver:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"JuMP.optimize!(model)","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We verify that the solver has found a feasible solution:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"JuMP.primal_status(model)","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"We can now obtain this feasible solution with:","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"value(V)","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"","category":"page"},{"location":"generated/Lyapunov Function Search/","page":"Lyapunov Function Search","title":"Lyapunov Function Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"EditURL = \"https://github.com/jump-dev/SumOfSquares.jl/blob/master/examples/Motzkin.jl\"","category":"page"},{"location":"generated/Motzkin/#Motzkin","page":"Motzkin","title":"Motzkin","text":"","category":"section"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"(Image: ) (Image: ) Adapted from: (3.6) and (3.19) of [BPT12]","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"[BPT12] Blekherman, G.; Parrilo, P. A. & Thomas, R. R. Semidefinite Optimization and Convex Algebraic Geometry. Society for Industrial and Applied Mathematics, 2012.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"The first explicit example of nonnegative polynomial that is not a sum of squares was found by Motzkin in 1967. By the Arithmetic-geometric mean, $ \\frac{x^4y^2 + x^2y^4 + 1}{3} \\ge \\sqrt[3]{x^4y^2 \\cdot x^2y^4 \\cdot 1} = x^2y^2 $ hence $ x^4y^2 + x^2y^4 + 1 - 3x^2y^2 \\ge 0. $ The code belows construct the Motzkin polynomial using DynamicPolynomials.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"using DynamicPolynomials\n@polyvar x y\nmotzkin = x^4*y^2 + x^2*y^4 + 1 - 3x^2*y^2","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"The Motzkin polynomial is nonnegative but is not a sum of squares as we can verify numerically as follows. We first need to pick an SDP solver, see here for a list of the available choices.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"using SumOfSquares\nimport CSDP\nsolver = optimizer_with_attributes(CSDP.Optimizer, MOI.Silent() => true)\nmodel = SOSModel(solver)\n@constraint(model, motzkin >= 0) # We constraint `motzkin` to be a sum of squares\n\noptimize!(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"We see that the problem is detected as infeasible...","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"termination_status(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"... and that the dual solution is a certificate of the infeasibility of the problem.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"dual_status(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"Even if the Motzkin polynomial is not a sum of squares, it can still be certified to be nonnegative using sums of squares. Indeed a polynomial is certified to be nonnegative if it is equal to a fraction of sums of squares. The Motzkin polynomial is equal to a fraction of sums of squares whose denominator is x^2 + y^2. This can be verified numerically as follows:","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"model = SOSModel(solver)\n@constraint(model, (x^2 + y^2) * motzkin >= 0) # We constraint the `(x^2 + y^2) * motzkin` to be a sum of squares\n\noptimize!(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"Now the problem is declared feasible by the solver...","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"termination_status(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"... and the primal solution is a feasible point, hence it is a certificate of nonnegativity of the Motzkin polynomial.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"primal_status(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"One may consider ourself lucky to have had the intuition that x^2 + y^2 would work as denominator. In fact, the search for the denominator can be carried out in parallel to the search of the numerator. In the example below, we search for a denominator with monomials of degrees from 0 to 2. If none is found, we can increase the maximum degree 2 to 4, 6, 8, ... This gives a hierarchy of programs to try in order to certify the nonnegativity of a polynomial by identifying it with a fraction of sum of squares polynomials. In the case of the Motzkin polynomial we now that degree 2 is enough since x^2 + y^2 works.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"model = SOSModel(solver)\nX = monomials([x, y], 0:2)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"We create a quadratic polynomial that is not necessarily a sum of squares since this is implied by the next constraint: deno >= 1.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"@variable(model, deno, Poly(X))","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"We want the denominator polynomial to be strictly positive, this prevents the trivial solution deno = 0 for instance.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"@constraint(model, deno >= 1)\n@constraint(model, deno * motzkin >= 0)\noptimize!(model)\n\ntermination_status(model)\n\nprimal_status(model)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"We can check the denominator found by the program using JuMP.value","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"value(deno)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"Because a picture is worth a thousand words let's plot the beast. We can easily extend Plots by adding a recipe to plot bivariate polynomials.","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"using RecipesBase\n@recipe function f(x::AbstractVector, y::AbstractVector, p::Polynomial)\n    x, y, (x, y) -> p(variables(p) => [x, y])\nend\nimport Plots\nPlots.plot(\n    range(-2, stop=2, length=100),\n    range(-2, stop=2, length=100),\n    motzkin,\n    st = [:surface],\n    seriescolor=:heat,\n    colorbar=:none,\n    clims = (-10, 80)\n)","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"","category":"page"},{"location":"generated/Motzkin/","page":"Motzkin","title":"Motzkin","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#SumOfSquares-–-Sum-of-Squares-Programming-for-Julia","page":"Index","title":"SumOfSquares –- Sum of Squares Programming for Julia","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"SumOfSquares implements Sum of Squares reformulation for PolyJuMP, enabling the creation of sum of squares variables and constraints in JuMP.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The polynomial can be represented by any library implementing the MultivariatePolynomial.jl interface. That is, you can currently choose between DynamicPolynomials and TypedPolynomials. As a rule of thumb, if you know at compile time (or at the time you are writing your code), the number of variable and that this number is small, use TypedPolynomials, otherwise, use DynamicPolynomials.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Some presentations on, or using, SumOfSquares (see here for the source code of the presentations):","category":"page"},{"location":"","page":"Index","title":"Index","text":"Tillmann Weisser, Benoît Legat, Chris Coey, Lea Kapelevich and Juan Pablo Vielma at JuliaCon 2019 [Slides] [Video]\nBenoît Legat at CNLS 2019 [Slides]\nBenoît Legat at EURO 2019 [Slides]\nBenoît Legat at juliaday Nantes 2019 [Slides]\nBenoît Legat at Summer School on Numerical Computing in Algebraic Geometry 2018 [Poster]\nBenoît Legat at The First Annual JuMP-dev Workshop 2017 [Slides] [Video]\nJoey Huchette at SIAM Opt 2017","category":"page"},{"location":"#Contents","page":"Index","title":"Contents","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages = [\"sumofsquares.md\", \"variables.md\", \"constraints.md\"]\nDepth = 2","category":"page"}]
}
